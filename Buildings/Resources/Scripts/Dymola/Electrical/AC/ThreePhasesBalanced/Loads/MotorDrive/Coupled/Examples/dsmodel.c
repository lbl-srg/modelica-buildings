#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model Buildings.Electrical.AC.ThreePhasesBalanced.Loads.MotorDrive.Coupled.Examples.Chiller
 Dymola Version 2023 (64-bit), 2022-05-30 translated this at Wed Nov 20 14:36:42 2024

  OutputCPUtime = true;
 */

#include <matrixop.h>
#include "matrixop.c"
static const char* DymArrays13[1]={"SimpleLiquidWater"};
#if defined(DynSimStruct)
static double DymArrays11[3]={-47612.06896551724, 0.0, -47612.06896551724};
static double DymArrays12[3]={1.0, 1.0, 1.0};
static double DymArrays2[3]={276.15, 4184.0, 4184.0};
static double DymArrays6[3]={303.15, 278.15, 1.0};
static double DymArrays9[3]={57612.06896551724, 0.0, 57612.06896551724};
static double DymArrays5[4]={-47612.06896551724, 57612.06896551724, -10.0, 10.0};
static double DymArrays1[4]={4.0, 4.0, 4.0, 4.0};
static double DymArrays7[4]={995.586, 300000.0, 293.15, 995.586};
static double DymArrays3[5]={-47612.06896551724, 57612.06896551724, -10.0, 10.0,
   10000.0};
static double DymArrays4[7]={0.5, 4.761206896551724, 303.15, 278.15, 1.0, 2.0, 
  2.0};
static double DymArrays0[11]={-47612.06896551724, 57612.06896551724, -10.0, 10.0,
   10000.0, 1000.0, 1000.0, 0.5, 4.761206896551724, 303.15, 278.15};
static double DymArrays10[11]={1.137955759214083E-07, 8787687.850805722, 
  -131815317.76208583, 9189591473820622.0, -2.4498024661141544E+23, 
  3.184488937035004E+30, -1.991391760738378E+37, 4.789399565609649E+43, 300000.0,
   293.15, 4184.0};
static double DymArrays8[11]={1.3769614953517503E-07, 7262367.200359121, 
  -108935508.00538681, 6276295304989385.0, -1.382744099138063E+23, 
  1.485436437497393E+30, -7.67670083805573E+36, 1.5258173996893662E+43, 300000.0,
   293.15, 4184.0};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_BaseClasses_smoothTransition
  (double  x0_0, double  delta0_0, double  deltaInv0_0, double  a0_0, double  
  b0_0, double  c0_0, double  d0_0, double  e0_0, double  f0_0);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_polynomial(double  
  x0_0, RealArray   a0_0);
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow
discrete input Real m_flow(unit = "kg/s") "Mass flow rate in design flow direction";
discrete input Real k "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate where transition to turbulent flow occurs";
discrete output Real dp(unit = "Pa", displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
protected 
discrete Real dp_turbulent(start = (m_flow_turbulent/k)^2, unit = "Pa", displayUnit = "bar") "Pressure where flow changes to turbulent";
discrete Real m_flowNorm(start = m_flow/m_flow_turbulent) "Normalised mass flow rate";
discrete Real m_flowNormSq(start = m_flowNorm^2) "Square of normalised mass flow rate";
public 
algorithm 
dp := smooth(2, (if noEvent(abs(m_flow) > m_flow_turbulent) then noEvent((if m_flow > 0 then 1 else (if m_flow < 0 then -1 else 0)))*(m_flow/k)^2 else (0.375+(0.75-0.125*m_flowNormSq)*m_flowNormSq)*dp_turbulent*m_flowNorm));
annotation(derivative(zeroDerivative=k, zeroDerivative=m_flow_turbulent)=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der, Inline=false, smoothOrder=2);
end Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow;

  */
DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent) {
  PushContext("Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow")
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   dpx_0turbulent;
    double   mx_0flowNorm;
    double   mx_0flowNormSq;
    dp0_0=0;
    dpx_0turbulent = sqr(divGuarded(mx_0flowx_0turbulent,"m_flow_turbulent",k0_0,
      "k"));
    mx_0flowNorm = divGuarded(mx_0flow,"m_flow",mx_0flowx_0turbulent,
      "m_flow_turbulent");
    mx_0flowNormSq = sqr(mx_0flowNorm);
    /* Start of real code */
      dp0_0 = IF fabs(mx_0flow) > mx_0flowx_0turbulent THEN (IF mx_0flow > 0
         THEN 1 ELSE IF mx_0flow < 0 THEN -1 ELSE 0)*sqr(divGuarded(mx_0flow,
        "m_flow",k0_0,"k")) ELSE (0.375+(0.75-0.125*mx_0flowNormSq)*
        mx_0flowNormSq)*dpx_0turbulent*mx_0flowNorm;
    /* Output section */
    PopContext()
    return dp0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition
discrete input Real x "Abscissa value";
discrete input Real delta(min = 1E-15) "Abscissa value below which approximation occurs";
discrete input Real deltaInv(start = 1/delta) "Inverse value of delta";
discrete input Real a(start = (-15)*deltaInv) "Polynomial coefficient";
discrete input Real b(start = 119*deltaInv^2) "Polynomial coefficient";
discrete input Real c(start = (-361)*deltaInv^3) "Polynomial coefficient";
discrete input Real d(start = 534*deltaInv^4) "Polynomial coefficient";
discrete input Real e(start = (-380)*deltaInv^5) "Polynomial coefficient";
discrete input Real f(start = 104*deltaInv^6) "Polynomial coefficient";
discrete output Real y "Function value";
protected 
discrete Real aX "Absolute value of x";
public 
algorithm 
aX := abs(x);
y := (if x >= 0 then 1 else -1)*(a+aX*(b+aX*(c+aX*(d+aX*(e+aX*f)))));
annotation(derivative(zeroDerivative=a, zeroDerivative=b, zeroDerivative=c, zeroDerivative=d, zeroDerivative=delta, zeroDerivative=deltaInv, zeroDerivative=e, zeroDerivative=f)=Buildings.Utilities.Math.Functions.BaseClasses.der_smoothTransition, smoothOrder=2);
end Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_BaseClasses_smoothTransition
  (double  x0_0, double  delta0_0, double  deltaInv0_0, double  a0_0, double  
  b0_0, double  c0_0, double  d0_0, double  e0_0, double  f0_0) {
  PushContext("Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   aX0_0;
    y0_0=0;
    aX0_0=0;
    /* Start of real code */
      aX0_0 = fabs(x0_0);
      y0_0 = (IF x0_0 >= 0 THEN 1 ELSE -1)*(a0_0+aX0_0*(b0_0+aX0_0*(c0_0+aX0_0*(
        d0_0+aX0_0*(e0_0+aX0_0*f0_0)))));
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.polynomial
discrete input Real x "Independent variable";
discrete input Real a[:] "Coefficients";
discrete output Real y "Result";
protected 
parameter Integer n = size(a, 1)-1;
discrete Real xp[n+1] "Powers of x";
public 
algorithm 
xp[1] := 1;
for i in (1:n) loop
xp[i+1] := xp[i]*x;
end for;
y := a*xp;
annotation(smoothOrder=999);
end Buildings.Utilities.Math.Functions.polynomial;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_polynomial(double  
  x0_0, RealArray   a0_0) {
  PushContext("Buildings.Utilities.Math.Functions.polynomial")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    int   n0_0;
    RealArray    xp0_0;
    MarkObject retmark_ = PushMark();
    y0_0=0;
    n0_0 = DYNSizeSimple(a0_0, 1)-1;
    xp0_0=RealTemporary( 1, n0_0+1);
    PushMark();
    RealFillAssign( xp0_0, 0);
    /* Start of real code */
      SetRealElement(1, xp0_0, (SizeType)(1));
      {
        int end_ = n0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(RealElement( xp0_0, (SizeType)(i0_0_0))*x0_0, xp0_0, 
            (SizeType)(i0_0_0+1));
        }
      }
      y0_0 = RealMultiplyVV (a0_0,xp0_0);
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.checkBoundary
input String mediumName;
input String substanceNames[:] "Names of substances";
input Boolean singleState;
input Boolean define_p;
discrete input Real X_boundary[:];
input String modelName(start = "??? boundary ???");
protected 
Integer nX(start = size(X_boundary, 1));
String X_str;
public 
algorithm 
assert( not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""+modelName+"\":
The selected medium \""+mediumName+"\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");
for i in (1:nX) loop
assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\":
The boundary value X_boundary("+       String(i, true, 0)+") = "+       String(X_boundary[i], true, 0)+"
is negative. It must be positive.
");
end for;
if (nX > 0 and abs(sum(X_boundary)-1.0) > 1E-10) then 
X_str := "";
for i in (1:nX) loop
X_str := X_str+"   X_boundary["+       String(i, true, 0)+"] = "+       String(X_boundary[i], true, 0)+" \""+substanceNames[i]+"\"\n";
end for;
ModelicaError("The boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\"\n"+"do not sum up to 1. Instead, sum(X_boundary) = "+       String(sum(X_boundary), true, 0)+":\n"+X_str);
end if;
end Modelica.Fluid.Utilities.checkBoundary;

  */
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Fluid.Utilities.checkBoundary")
  {
    /* Declare outputs and temporaries */
    int   nX0_0;
    const char*   Xx_0str;
    MarkObject retmark_ = PushMark();
    nX0_0 = DYNSizeSimple(Xx_0boundary, 1);
    Xx_0str="";
    /* Start of real code */
      AssertModelica( NOT singleState0_0 OR singleState0_0 AND definex_0p,
        " not singleState or singleState and define_p", StringAdd(StringAdd(
        StringAdd(StringAdd("\nWrong value of parameter define_p (= false) in model \"",
        modelName0_0),"\":\nThe selected medium \""),mediumName0_0),
        "\" has Medium.singleState=true.\nTherefore, an boundary density cannot be defined and\ndefine_p = true is required.\n"));
      {
        int end_ = nX0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          AssertModelica(RealElement( Xx_0boundary, (SizeType)(i0_0_0)) >= 0.0,
            "X_boundary[i] >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
            StringAdd(StringAdd(StringAdd(StringAdd("\nWrong boundary mass fractions in medium \"",
            mediumName0_0),"\" in model \""),modelName0_0),"\":\nThe boundary value X_boundary("),
            Integer2String2(i0_0_0, true, 0)),") = "),Real2String2(RealElement( 
            Xx_0boundary, (SizeType)(i0_0_0)), true, 0)),"\nis negative. It must be positive.\n"));
        }
      }
      if (nX0_0 > 0 AND fabs(Realsum( Xx_0boundary)-1.0) > 1E-10) {
        Xx_0str = SqueezeString("", retSMark_);
        Release();
        {
          int end_ = nX0_0;
          int i0_0_0;
          for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
            Xx_0str = SqueezeString(StringAdd(StringAdd(StringAdd(StringAdd(
              StringAdd(StringAdd(StringAdd(Xx_0str,"   X_boundary["),
              Integer2String2(i0_0_0, true, 0)),"] = "),Real2String2(
              RealElement( Xx_0boundary, (SizeType)(i0_0_0)), true, 0))," \""),
              StringElement( substanceNames0_0, (SizeType)(i0_0_0))),"\"\n"), retSMark_);
          }
        }
        ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd(StringAdd("The boundary mass fractions in medium \"",
          mediumName0_0),"\" in model \""),modelName0_0),"\"\n"),
          "do not sum up to 1. Instead, sum(X_boundary) = "),Real2String2(
          Realsum( Xx_0boundary), true, 0)),":\n"),Xx_0str));
        Release();
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(2)
BreakSectionFunctionDef(3)
#define NX_    9
#define NX2_   1
#define NU_    0
#define NY_    2
#define NW_    593
#define NWP_   502
#define NP_    106
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   1
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -2098860852
#define NHash2_ -1958995653
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  5
#define NSamp_ 0
#define NCons_ 0
#define NA_    335
#define SizePre_ 0
#define SizeEq_ 5
#define SizeDelay_ 0
#define QNLmax_ 2
#define MAXAux 20
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 128
#define NGlobalHelpI_ 48
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="Buildings.Electrical.AC.ThreePhasesBalanced.Loads.MotorDrive.Coupled.Examples.Chiller";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/vmg5298/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[19]={7 , 3 , 1 , 3 , 8 , 1 , 2 , 1 , 4 , 1 , 5 , 1
   , 6 , 1 , 7 , 1 , 9 , 0 , 0};
static int QJacobianGrp0[10]={1, 0, 1, 1, 1, 1, 1, 0, 1, 0};
static int QJacobianGrp1[10]={2, 2, 0, 2, 2, 2, 2, 2, 0, 0};
static int QJacobianGrp2[9]={1, 4 , 5 , 2 , 4 , 5 , 6 , 7 , 0};
static int QJacobianGrp3[9]={1, 5 , 5 , 2 , 4 , 5 , 6 , 7 , 0};
static int QJacobianGrp4[9]={1, 6 , 5 , 2 , 4 , 5 , 6 , 7 , 0};
static int QJacobianGrp5[9]={1, 7 , 5 , 2 , 4 , 5 , 6 , 7 , 0};
static int QJacobianGrp6[10]={0, 0, 9, 9, 9, 9, 9, 0, 9, 0};
DYMOLA_STATIC struct QJacobianTag_ QJacobianGC2_[8]={
{0, QJacobianGrp0},{0, QJacobianGrp1},{1, QJacobianGrp2},{1, QJacobianGrp3},{1, 
  QJacobianGrp4},{1, QJacobianGrp5},{0, QJacobianGrp6},{0,0}};
DYMOLA_STATIC double QJacobianCD_[10]={0  , 44 , 50 , 66 , 63 , 64 , 63 , 60 , 121
   , 60};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations
DYNX(Y_,0) = CurrentClockTime;
if (DYNEvent) DYNX(Y_,1) += 1;
InitialSection
#if defined(DynSimStruct)
DYNX(W_,509) = 0;
DYNX(W_,510) = 0;
DYNX(W_,516) = 83680.0;
DYNX(W_,518) = 293.15;
DYNX(W_,519) = 83680.0;
DYNX(W_,520) = 83680.0;
DYNX(W_,521) = 83680.0;
DYNX(W_,522) = 293.15;
DYNX(W_,523) = 293.15;
DYNX(W_,524) = 293.15;
DYNX(W_,525) = 293.15;
DYNX(W_,527) = 293.15;
DYNX(W_,528) = 293.15;
DYNX(W_,532) = 305.15;
DYNX(W_,533) = 276.15;
DYNX(W_,534) = 293.15;
DYNX(W_,535) = 293.15;
DYNX(W_,536) = 293.15;
DYNX(W_,537) = 293.15;
DYNX(W_,545) = 57612.06896551724;
DYNX(W_,546) = -47612.06896551724;
DYNX(W_,548) = 0;
#endif
DYNX(Aux_,0) = 83680.0;
DYNX(Aux_,2) = 83680.0;
DYNX(Aux_,4) = 83680.0;
DYNX(Aux_,6) = 83680.0;
DYNX(Aux_,11) = 83680.0;
DYNX(Aux_,15) = 83680.0;
DYNX(Aux_,16) = 83680.0;
DYNX(Aux_,18) = 83680.0;
DYNX(Aux_,0) = 83680.0;
DYNX(Aux_,2) = 83680.0;
DYNX(Aux_,4) = 83680.0;
DYNX(Aux_,6) = 83680.0;
DYNX(Aux_,11) = 83680.0;
DYNX(Aux_,15) = 83680.0;
DYNX(Aux_,16) = 83680.0;
DYNX(Aux_,18) = 83680.0;

InitialSection
#if defined(DynSimStruct)
DYNX(W_,0) = 10000.0;
DYNX(W_,3) = 1;
DYNX(W_,4) = false;
DYNX(W_,6) = 3;
DYNX(W_,8) = false;
DYNX(W_,9) = false;
DYNX(W_,10) = false;
DYNX(W_,11) = false;
DYNX(W_,13) = true;
DYNX(W_,14) = 1;
DYNX(W_,15) = false;
DYNX(W_,17) = 3;
DYNX(W_,19) = false;
DYNX(W_,20) = false;
DYNX(W_,21) = false;
DYNX(W_,22) = false;
DYNX(W_,24) = true;
DYNX(W_,27) = true;
DYNX(W_,28) = true;
DYNX(W_,33) = true;
DYNX(W_,47) = 1;
DYNX(W_,48) = false;
DYNX(W_,49) = 3;
DYNX(W_,51) = false;
DYNX(W_,52) = false;
DYNX(W_,53) = false;
DYNX(W_,54) = false;
DYNX(W_,55) = false;
DYNX(W_,56) = true;
DYNX(W_,57) = false;
DYNX(W_,58) = 1;
DYNX(W_,59) = false;
DYNX(W_,61) = 3;
DYNX(W_,63) = false;
DYNX(W_,64) = false;
DYNX(W_,65) = false;
DYNX(W_,66) = false;
DYNX(W_,67) = false;
DYNX(W_,68) = true;
DYNX(W_,69) = false;
DYNX(W_,70) = true;
DYNX(W_,71) = true;
DYNX(W_,72) = 1.3769614953517504;
DYNX(W_,73) = 1.137955759214083;
DYNX(W_,76) = false;
memcpy(&DYNX(W_,81), &DymArrays0, sizeof(double)*11);
DYNX(W_,93) = 2;
DYNX(W_,94) = 2;
DYNX(W_,97) = true;
DYNX(W_,98) = true;
DYNX(W_,99) = 1.3769614953517504;
DYNX(W_,100) = 1.137955759214083;
DYNX(W_,103) = false;
DYNX(W_,113) = 1000;
DYNX(W_,114) = 1000;
DYNX(W_,124) = true;
DYNX(W_,125) = true;
DYNX(W_,126) = 1.3769614953517504;
DYNX(W_,127) = 1.137955759214083;
DYNX(W_,130) = false;
DYNX(W_,135) = true;
DYNX(W_,146) = 1000;
DYNX(W_,147) = 1000;
DYNX(W_,156) = 4;
DYNX(W_,158) = true;
DYNX(W_,164) = true;
DYNX(W_,165) = 1.3769614953517504;
DYNX(W_,167) = false;
DYNX(W_,173) = 1000;
DYNX(W_,176) = true;
DYNX(W_,178) = 4;
memcpy(&DYNX(W_,180), &DymArrays1, sizeof(double)*4);
DYNX(W_,190) = true;
DYNX(W_,191) = true;
DYNX(W_,193) = 2;
DYNX(W_,195) = true;
DYNX(W_,205) = true;
DYNX(W_,206) = false;
DYNX(W_,207) = true;
DYNX(W_,210) = false;
DYNX(W_,214) = true;
DYNX(W_,215) = true;
DYNX(W_,216) = false;
DYNX(W_,217) = false;
DYNX(W_,231) = 200;
DYNX(W_,233) = true;
DYNX(W_,234) = 1.3769614953517504;
DYNX(W_,236) = false;
DYNX(W_,240) = true;
DYNX(W_,242) = 1000;
DYNX(W_,246) = 1.3769614953517504;
DYNX(W_,247) = 1000;
DYNX(W_,259) = true;
DYNX(W_,260) = 1.137955759214083;
DYNX(W_,262) = false;
DYNX(W_,268) = 1000;
DYNX(W_,271) = true;
DYNX(W_,273) = 4;
memcpy(&DYNX(W_,275), &DymArrays1, sizeof(double)*4);
DYNX(W_,285) = true;
DYNX(W_,286) = true;
DYNX(W_,288) = 2;
DYNX(W_,290) = true;
DYNX(W_,300) = true;
DYNX(W_,301) = false;
DYNX(W_,302) = true;
DYNX(W_,305) = false;
DYNX(W_,309) = true;
DYNX(W_,310) = true;
DYNX(W_,311) = false;
DYNX(W_,312) = false;
DYNX(W_,326) = 200;
DYNX(W_,328) = true;
DYNX(W_,329) = 1.137955759214083;
DYNX(W_,331) = false;
DYNX(W_,335) = true;
DYNX(W_,337) = 1000;
DYNX(W_,341) = 1.137955759214083;
DYNX(W_,342) = 1000;
DYNX(W_,357) = 3;
DYNX(W_,358) = false;
DYNX(W_,361) = 3;
DYNX(W_,363) = true;
DYNX(W_,386) = false;
DYNX(W_,387) = false;
DYNX(W_,393) = false;
DYNX(W_,394) = false;
DYNX(W_,413) = false;
DYNX(W_,414) = false;
DYNX(W_,421) = false;
DYNX(W_,422) = false;
DYNX(W_,431) = false;
DYNX(W_,432) = false;
DYNX(W_,441) = false;
DYNX(W_,442) = false;
DYNX(W_,450) = false;
DYNX(W_,452) = true;
DYNX(W_,456) = 2;
DYNX(W_,466) = 1;
DYNX(W_,474) = 1;
DYNX(W_,476) = true;
DYNX(W_,477) = false;
DYNX(W_,494) = 1;
DYNX(W_,498) = true;
memcpy(&DYNX(W_,499), &DymArrays2, sizeof(double)*3);
DYNX(W_,37) = 1;
DYNX(W_,92) = 1.0;
DYNX(W_,150) = false;
DYNX(W_,151) = false;
DYNX(W_,152) = false;
DYNX(W_,153) = false;
DYNX(W_,154) = 0.1;
DYNX(W_,155) = 0.1;
DYNX(W_,463) = 0;
DYNX(W_,38) = 3;
DYNX(W_,40) = true;
DYNX(W_,42) = 1.0;
DYNX(W_,43) = false;
DYNX(W_,74) = 0.00013769614953517505;
DYNX(W_,75) = 0.0001137955759214083;
DYNX(W_,101) = 0.00013769614953517505;
DYNX(W_,102) = 0.0001137955759214083;
memcpy(&DYNX(W_,108), &DymArrays3, sizeof(double)*5);
memcpy(&DYNX(W_,117), &DymArrays4, sizeof(double)*7);
DYNX(W_,128) = 0.00013769614953517505;
DYNX(W_,129) = 0.0001137955759214083;
DYNX(W_,354) = 10000.0;
DYNX(W_,142) = 4.761206896551724;
memcpy(&DYNX(W_,136), &DymArrays5, sizeof(double)*4);
DYNX(W_,141) = 0.5;
memcpy(&DYNX(W_,143), &DymArrays6, sizeof(double)*3);
DYNX(W_,148) = 2.0;
DYNX(W_,149) = 2.0;
DYNX(W_,161) = 276.15;
DYNX(W_,159) = 0.5;
DYNX(W_,160) = false;
DYNX(W_,162) = 4184;
DYNX(W_,163) = 4184;
DYNX(W_,166) = 0.00013769614953517505;
DYNX(W_,169) = 0;
DYNX(W_,170) = 0;
DYNX(W_,171) = true;
DYNX(W_,172) = false;
DYNX(W_,174) = false;
DYNX(W_,175) = 0.1;
DYNX(W_,187) = 1;
DYNX(W_,188) = false;
DYNX(W_,189) = false;
DYNX(W_,192) = 1.3769614953517504;
DYNX(W_,194) = 0.00013769614953517505;
DYNX(W_,252) = 995.586;
memcpy(&DYNX(W_,199), &DymArrays7, sizeof(double)*4);
DYNX(W_,208) = 1.3769614953517504;
DYNX(W_,209) = 0.00013769614953517505;
DYNX(W_,212) = 0;
DYNX(W_,213) = 0;
DYNX(W_,218) = true;
memcpy(&DYNX(W_,220), &DymArrays8, sizeof(double)*11);
DYNX(W_,235) = 0.00013769614953517505;
DYNX(W_,238) = 0;
DYNX(W_,239) = 0;
DYNX(W_,241) = false;
DYNX(W_,243) = false;
DYNX(W_,250) = true;
DYNX(W_,248) = 0.1;
DYNX(W_,244) = 0.13769614953517503;
DYNX(W_,245) = 0.001;
DYNX(W_,249) = 0.04354334575662886;
DYNX(W_,251) = 0;
memcpy(&DYNX(W_,256), &DymArrays9, sizeof(double)*3);
DYNX(W_,261) = 0.0001137955759214083;
DYNX(W_,264) = 0;
DYNX(W_,265) = 0;
DYNX(W_,266) = true;
DYNX(W_,267) = false;
DYNX(W_,269) = false;
DYNX(W_,270) = 0.1;
DYNX(W_,282) = 1;
DYNX(W_,283) = false;
DYNX(W_,284) = false;
DYNX(W_,287) = 1.137955759214083;
DYNX(W_,289) = 0.0001137955759214083;
DYNX(W_,347) = 995.586;
memcpy(&DYNX(W_,294), &DymArrays7, sizeof(double)*4);
DYNX(W_,303) = 1.137955759214083;
DYNX(W_,304) = 0.0001137955759214083;
DYNX(W_,307) = 0;
DYNX(W_,308) = 0;
DYNX(W_,313) = true;
memcpy(&DYNX(W_,315), &DymArrays10, sizeof(double)*11);
DYNX(W_,330) = 0.0001137955759214083;
DYNX(W_,333) = 0;
DYNX(W_,334) = 0;
DYNX(W_,336) = false;
DYNX(W_,338) = false;
DYNX(W_,345) = true;
DYNX(W_,343) = 0.1;
DYNX(W_,339) = 0.1137955759214083;
DYNX(W_,340) = 0.001;
DYNX(W_,344) = 0.03598532075622642;
DYNX(W_,346) = 0;
memcpy(&DYNX(W_,351), &DymArrays11, sizeof(double)*3);
DYNX(W_,355) = 10000.0;
memcpy(&DYNX(W_,364), &DymArrays2, sizeof(double)*3);
DYNX(W_,388) = 3;
DYNX(W_,395) = 3;
DYNX(W_,415) = 3;
DYNX(W_,423) = 3;
DYNX(W_,433) = 3;
DYNX(W_,443) = 3;
#endif
BreakSectionFunctionCallNew(2);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
#if defined(DynSimStruct)
DYNX(W_,462) = 2;
DYNX(W_,464) = true;
DYNX(W_,467) = 0.0;
memcpy(&DYNX(W_,470), &DymArrays12, sizeof(double)*3);
DYNX(W_,478) = 0;
DYNX(W_,483) = 1;
DYNX(W_,484) = -1;
DYNX(W_,489) = true;
DYNX(W_,490) = true;
DYNX(W_,492) = 2;
DYNX(W_,493) = 0.0;
DYNX(W_,495) = 0.0;
DYNX(W_,473) = 0;
DYNX(W_,32) = 0;
DYNX(W_,360) = 0;
DYNX(W_,451) = 0;
DYNX(W_,157) = 1;
DYNX(W_,197) = 0;
DYNX(W_,198) = 0;
DYNX(W_,211) = 0.0;
DYNX(W_,232) = 0;
DYNX(W_,292) = 0;
DYNX(W_,293) = 0;
DYNX(W_,306) = 0.0;
DYNX(W_,327) = 0;
DYNX(W_,359) = 0;
DYNX(W_,391) = 0;
DYNX(W_,397) = 0;
DYNX(W_,417) = 0;
DYNX(W_,425) = 0;
DYNX(W_,435) = 0;
DYNX(W_,445) = 0;
DYNX(W_,453) = 0;
DYNX(W_,389) = 0;
DYNX(W_,479) = 0.0;
DYNX(W_,497) = false;
DYNX(W_,496) = 0.0;
DYNX(W_,480) = 0.0;
DYNX(W_,396) = false;
DYNX(W_,390) = false;
DYNX(W_,424) = false;
DYNX(W_,444) = false;
DYNX(W_,416) = false;
DYNX(W_,434) = false;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,21) > 10000.0,"sin2.p_in_internal > 10000.0", StringAdd(
  StringAdd("In Chiller.sin2: The parameter value p=",Real2String2(DYNX(DP_,21),
   true, 0))," is low for water. This is likely an error."));
AssertModelica(DYNX(DP_,24) > 10000.0,"sin1.p_in_internal > 10000.0", StringAdd(
  StringAdd("In Chiller.sin1: The parameter value p=",Real2String2(DYNX(DP_,24),
   true, 0))," is low for water. This is likely an error."));
BoundParameterSection
DYNX(DYNhelp,0) = divinvGuarded(DYNX(DP_,0),"dTEva_nominal");
DYNX(W_,1) =  -DYNX(DYNhelp,0)*2.380952380952381*DYNX(DP_,2);
DYNX(DYNhelp,1) = divinvGuarded(DYNX(DP_,2),"COP_nominal");
DYNX(W_,2) = DYNX(DYNhelp,1)*DYNX(W_,1)*(DYNX(DP_,2)+1);
DYNX(W_,12) = DYNX(W_,2);
DYNX(W_,23) = DYNX(W_,1);
DYNX(W_,29) = DYNX(DP_,11);
DYNX(W_,30) = DYNX(DP_,12);
DYNX(W_,31) = DYNX(DP_,13);
DYNX(W_,35) = DYNX(W_,1);
DYNX(W_,36) = 0.0001*DYNX(W_,35);
DYNX(W_,44) = IF DYNX(DP_,16) < 1E-10 THEN 0 ELSE divinvGuarded(DYNX(DP_,16),
  "senTem.tauHeaTra");
DYNX(W_,45) = IF DYNX(W_,40) THEN divGuarded(DYNX(DP_,16),"senTem.tauHeaTra",
  DYNX(W_,37),"senTem.tau") ELSE 1;
DYNX(W_,95) = DYNX(DP_,28);
DYNX(W_,96) = DYNX(DP_,29);
DYNX(W_,115) = DYNX(DP_,26);
DYNX(W_,116) = DYNX(DP_,27);
DYNX(W_,140) = DYNX(W_,116);
DYNX(W_,177) = DYNX(DP_,50);
DYNX(W_,179) = DYNX(DP_,52);
DYNX(W_,184) = DYNX(DP_,54);
DYNX(W_,185) = DYNX(W_,179);
DYNX(W_,186) = DYNX(DP_,55);
DYNX(DYNhelp,2) = divinvGuarded(DYNX(W_,252),"chi.mecChi.chi.con.rho_default");
DYNX(W_,196) = DYNX(DYNhelp,2)*1.3769614953517504*DYNX(W_,177);
DYNX(W_,203) = DYNX(W_,184);
DYNX(W_,204) = DYNX(W_,185);
DYNX(W_,253) = DYNX(DP_,54);
DYNX(W_,254) = DYNX(W_,179);
DYNX(W_,255) = 4184*(DYNX(W_,254)-273.15);
DYNX(W_,272) = DYNX(DP_,51);
DYNX(W_,274) = DYNX(DP_,53);
DYNX(W_,279) = DYNX(DP_,61);
DYNX(W_,280) = DYNX(W_,274);
DYNX(W_,281) = DYNX(DP_,62);
DYNX(DYNhelp,3) = divinvGuarded(DYNX(W_,347),"chi.mecChi.chi.eva.rho_default");
DYNX(W_,291) = DYNX(DYNhelp,3)*1.137955759214083*DYNX(W_,272);
DYNX(W_,298) = DYNX(W_,279);
DYNX(W_,299) = DYNX(W_,280);
DYNX(W_,348) = DYNX(DP_,61);
DYNX(W_,349) = DYNX(W_,274);
DYNX(W_,350) = 4184*(DYNX(W_,349)-273.15);
DYNX(W_,356) = DYNX(DP_,49);
DYNX(DYNhelp,4) = divinvGuarded(DYNX(W_,115),"chi.mecChi.Nrpm_nominal");
DYNX(W_,362) = DYNX(DYNhelp,4);
DYNX(W_,367) = DYNX(W_,95);
DYNX(W_,368) = DYNX(W_,96);
DYNX(W_,369) = DYNX(DP_,37);
DYNX(W_,370) = DYNX(DP_,38);
DYNX(W_,371) = DYNX(DP_,39);
DYNX(W_,372) = DYNX(DP_,40);
DYNX(W_,373) = DYNX(DP_,41);
DYNX(W_,374) = DYNX(DP_,43);
DYNX(W_,375) = DYNX(DP_,44);
DYNX(W_,376) = DYNX(DP_,45);
DYNX(W_,377) = DYNX(DP_,46);
DYNX(W_,378) = DYNX(DP_,47);
DYNX(W_,379) = DYNX(DP_,48);
DYNX(W_,383) = DYNX(W_,368);
DYNX(W_,384) = DYNX(W_,367);
DYNX(W_,385) = divGuarded(DYNX(W_,384),"chi.simMot.speBlo.P",2*DYNX(W_,383),
  "2*chi.simMot.speBlo.J");
DYNX(DYNhelp,5) = divinvGuarded(DYNX(W_,384),"chi.simMot.speBlo.P");
DYNX(W_,392) = DYNX(DYNhelp,5)*19.098593171027442;
DYNX(W_,398) = DYNX(W_,367);
DYNX(W_,399) = DYNX(W_,368);
DYNX(W_,400) = DYNX(W_,369);
DYNX(W_,401) = DYNX(W_,370);
DYNX(W_,402) = DYNX(W_,372);
DYNX(W_,403) = DYNX(W_,371);
DYNX(W_,404) = DYNX(W_,373);
DYNX(W_,405) = DYNX(W_,400);
DYNX(W_,406) = DYNX(W_,401);
DYNX(W_,407) = DYNX(W_,402);
DYNX(W_,408) = DYNX(W_,403);
DYNX(W_,409) = DYNX(W_,404);
DYNX(W_,410) = DYNX(W_,405);
DYNX(W_,411) = DYNX(W_,407);
DYNX(W_,412) = DYNX(W_,408);
DYNX(W_,418) = DYNX(W_,405);
DYNX(W_,419) = DYNX(W_,407);
DYNX(W_,420) = DYNX(W_,408);
DYNX(W_,426) = DYNX(W_,405);
DYNX(W_,427) = DYNX(W_,407);
DYNX(W_,428) = DYNX(W_,408);
DYNX(W_,429) = DYNX(W_,409);
DYNX(W_,430) = DYNX(W_,406);
DYNX(W_,436) = DYNX(W_,405);
DYNX(W_,437) = DYNX(W_,407);
DYNX(W_,438) = DYNX(W_,408);
DYNX(W_,439) = DYNX(W_,409);
DYNX(W_,440) = DYNX(W_,406);
DYNX(W_,446) = DYNX(W_,398);
DYNX(W_,447) = DYNX(W_,403);
DYNX(W_,448) = DYNX(W_,399);
DYNX(W_,454) = 6.283185307179586*DYNX(DP_,93);
DYNX(W_,455) = DYNX(W_,367)/(double)(120);
DYNX(W_,457) = 0.05*DYNX(W_,375);
DYNX(W_,458) = 15*DYNX(W_,376);
DYNX(W_,459) = DYNX(W_,377)*2;
DYNX(W_,460) = DYNX(W_,378);
DYNX(W_,461) = DYNX(W_,379);
AssertModelica(DYNX(W_,460) >= DYNX(W_,461),"chi.simMot.VFD.yMax >= chi.simMot.VFD.yMin",
   StringAdd(StringAdd(StringAdd(StringAdd("LimPID: Limits must be consistent. However, yMax (=",
  Real2String2(DYNX(W_,460), true, 0)),") < yMin (="),Real2String2(DYNX(W_,461),
   true, 0)),")"));
DYNX(W_,465) = DYNX(DP_,79);
DYNX(W_,475) = IF DYNX(W_,465) THEN 1 ELSE -1;
DYNX(W_,468) = DYNX(W_,475)*DYNX(DP_,94);
DYNX(W_,469) =  -DYNX(W_,475);
DYNX(W_,481) = DYNX(W_,475);
DYNX(W_,482) =  -DYNX(W_,475);
DYNX(W_,485) = DYNX(W_,457);
DYNX(W_,486) = divinvGuarded(DYNX(W_,457)*DYNX(DP_,96),"chi.simMot.VFD.k*chi.simMot.VFD.Ni");
DYNX(W_,487) = DYNX(W_,460);
DYNX(W_,488) = DYNX(W_,461);
AssertModelica(DYNX(W_,487) >= DYNX(W_,488),"chi.simMot.VFD.limiter.uMax >= chi.simMot.VFD.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(W_,487), true, 0)),") < uMin (="),Real2String2(DYNX(W_,488),
   true, 0)),")"));
DYNX(DYNhelp,6) = divinvGuarded(DYNX(W_,458),"chi.simMot.VFD.Ti");
DYNX(W_,491) = DYNX(DYNhelp,6);
BoundParameterConstantSection
  DYNX(W_,449) = 0;
DYNX(DYNhelp,7) = cos(DYNX(W_,31));
DYNX(W_,25) = DYNX(W_,30)*DYNX(DYNhelp,7);
DYNX(DYNhelp,8) = sin(DYNX(W_,31));
DYNX(W_,26) = DYNX(W_,30)*DYNX(DYNhelp,8);
DYNX(W_,380) = sqrtGuarded(sqr(DYNX(W_,25))+sqr(DYNX(W_,26)),"chi.simMot.v[1]^2+chi.simMot.v[2]^2");
DYNX(W_,219) = IF DYNX(W_,12) > 1.3769614953517503E-07 OR DYNX(W_,12) < 
  -1.3769614953517503E-07 THEN divinvGuarded(DYNX(W_,12),"chi.mecChi.chi.con.vol.steBal.port_a.m_flow")
   ELSE IF DYNX(W_,12) < 6.884807476758752E-08 AND DYNX(W_,12) > 
  -6.884807476758752E-08 THEN 52741977352851.98*DYNX(W_,12) ELSE 
  (PushModelContext(1,"Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition(chi.mecChi.chi.con.vol.steBal.port_a.m_flow, 1.3769614953517503E-07, 7262367.200359121, -108935508.00538681, 6276295304989385.0, -1.382744099138063E+23, 1.485436437497393E+30, -7.67670083805573E+36, 1.5258173996893662E+43)\nBuildings.Utilities.Math.Functions.inverseXRegularized(chi.mecChi.chi.con.vol.steBal.port_a.m_flow, 1.37696149...")
  Buildings_Utilities_Math_Functions_BaseClasses_smoothTransition(DYNX(W_,12), 
  1.3769614953517503E-07, 7262367.200359121, -108935508.00538681, 
  6276295304989385.0, -1.382744099138063E+23, 1.485436437497393E+30, 
  -7.67670083805573E+36, 1.5258173996893662E+43));
PopModelContext();
DYNX(W_,314) = IF DYNX(W_,23) > 1.137955759214083E-07 OR DYNX(W_,23) < 
  -1.137955759214083E-07 THEN divinvGuarded(DYNX(W_,23),"chi.mecChi.chi.eva.vol.steBal.port_a.m_flow")
   ELSE IF DYNX(W_,23) < 5.689778796070415E-08 AND DYNX(W_,23) > 
  -5.689778796070415E-08 THEN 77223457763198.5*DYNX(W_,23) ELSE (PushModelContext(1,
  "Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition(chi.mecChi.chi.eva.vol.steBal.port_a.m_flow, 1.137955759214083E-07, 8787687.850805722, -131815317.76208583, 9189591473820622.0, -2.4498024661141544E+23, 3.184488937035004E+30, -1.991391760738378E+37, 4.789399565609649E+43)\nBuildings.Utilities.Math.Functions.inverseXRegularized(chi.mecChi.chi.eva.vol.steBal.port_a.m_flow, 1.13795575...")
  Buildings_Utilities_Math_Functions_BaseClasses_smoothTransition(DYNX(W_,23), 
  1.137955759214083E-07, 8787687.850805722, -131815317.76208583, 
  9189591473820622.0, -2.4498024661141544E+23, 3.184488937035004E+30, 
  -1.991391760738378E+37, 4.789399565609649E+43));
PopModelContext();
DYNX(W_,34) = 4184*(DYNX(DP_,22)-273.15);
DYNX(W_,46) = 273.15+0.0002390057361376673*DYNX(W_,34);
DYNX(DYNhelp,9) = divinvGuarded(DYNX(W_,35),"senTem.m_flow_nominal");
DYNX(W_,41) = DYNX(DYNhelp,9)*DYNX(W_,23);
DYNX(W_,39) = IF DYNX(W_,23) > DYNX(W_,36) THEN DYNX(W_,41) ELSE IF DYNX(W_,23)
   <  -DYNX(W_,36) THEN  -DYNX(W_,41) ELSE IF DYNX(W_,36) > 0 THEN divGuarded((
  -0.5)*DYNX(W_,23)*(sqr(divGuarded(DYNX(W_,23),"senTem.port_a.m_flow",
  DYNX(W_,36),"senTem.m_flow_small"))-3)*DYNX(W_,41),"(-0.5)*(senTem.port_a.m_flow*((senTem.port_a.m_flow/senTem.m_flow_small)^2-3)*senTem.mNor_flow)",
  DYNX(W_,36),"senTem.m_flow_small") ELSE 0.0;
DYNX(W_,60) = 4184*(DYNX(DP_,25)-273.15);
DYNX(Aux_,1) = DYNX(W_,60);
DYNX(Aux_,3) = DYNX(W_,34);
DYNX(Aux_,5) = DYNX(W_,60);
DYNX(Aux_,7) = DYNX(W_,34);
DYNX(Aux_,9) = DYNX(W_,60);
DYNX(Aux_,10) = DYNX(W_,60);
DYNX(Aux_,13) = DYNX(W_,34);
DYNX(Aux_,14) = DYNX(W_,34);
DYNX(Aux_,17) = DYNX(W_,60);
DYNX(Aux_,19) = DYNX(W_,34);
DYNX(DYNhelp,10) = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(chi.mecChi.chi.con.preDro.m_flow, 0.04354334575662886, 0.13769614953517503)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
  DYNX(W_,12), 0.04354334575662886, 0.13769614953517503));
PopModelContext();
DYNX(W_,237) = homotopy(DYNX(DYNhelp,10), 726.2367200359121*DYNX(W_,12));
DYNX(W_,5) = DYNX(W_,237)+DYNX(DP_,24);
DYNX(DYNhelp,11) = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(chi.mecChi.chi.eva.preDro.m_flow, 0.03598532075622642, 0.1137955759214083)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
  DYNX(W_,23), 0.03598532075622642, 0.1137955759214083));
PopModelContext();
DYNX(W_,332) = homotopy(DYNX(DYNhelp,11), 878.7687850805723*DYNX(W_,23));
DYNX(W_,16) = DYNX(W_,332)+DYNX(DP_,21);
DYNX(W_,77) = DYNX(W_,5)-DYNX(DP_,24);
DYNX(W_,78) = DYNX(W_,16)-DYNX(DP_,21);
DYNX(W_,79) = 273.15+0.0002390057361376673*DYNX(W_,60);
DYNX(W_,80) = 273.15+0.0002390057361376673*DYNX(W_,34);
DYNX(W_,104) = DYNX(W_,5)-DYNX(DP_,24);
DYNX(W_,105) = DYNX(W_,16)-DYNX(DP_,21);
DYNX(W_,106) = 273.15+0.0002390057361376673*DYNX(Aux_,1);
DYNX(W_,107) = 273.15+0.0002390057361376673*DYNX(Aux_,3);
DYNX(W_,131) = DYNX(W_,5)-DYNX(DP_,24);
DYNX(W_,132) = DYNX(W_,16)-DYNX(DP_,21);
DYNX(W_,133) = 273.15+0.0002390057361376673*DYNX(Aux_,5);
DYNX(W_,134) = 273.15+0.0002390057361376673*DYNX(Aux_,7);
DYNX(W_,168) = DYNX(W_,5)-DYNX(DP_,24);
DYNX(W_,263) = DYNX(W_,16)-DYNX(DP_,21);
DYNX(W_,381) = 6.283185307179586*DYNX(W_,29);
DYNX(W_,382) = 0.15915494309189535*DYNX(W_,381);
DYNX(W_,62) = DYNX(DP_,23);
DYNX(W_,50) = DYNX(DP_,20);
DYNX(W_,7) = DYNX(DP_,3);
DYNX(W_,18) = DYNX(DP_,9);
BoundParameterSection
InitialSection
InitialStartSection
InitialStartSection2
DYNX(W_,505) = DYNX(W_,255);
DYNX(W_,507) = DYNX(W_,350);
DYNX(W_,517) = DYNX(DP_,14);
DYNX(W_,538) = DYNX(W_,185);
DYNX(W_,539) = 4184*(DYNX(W_,185)-273.15);
DYNX(W_,541) = DYNX(W_,280);
DYNX(W_,542) = 4184*(DYNX(W_,280)-273.15);
InitialStartSection
DYNX(Aux_,8) = DYNX(W_,255);
DYNX(Aux_,12) = DYNX(W_,350);
DYNX(Aux_,8) = DYNX(W_,255);
DYNX(Aux_,12) = DYNX(W_,350);
InitialStartSection2
DYNX(X_,0) = DYNX(DP_,14);
DYNX(X_,2) = DYNX(DP_,82);
DYNX(X_,3) = DYNX(DP_,84);
DYNX(X_,4) = DYNX(DP_,86);
DYNX(X_,5) = DYNX(DP_,89);
DYNX(X_,6) = DYNX(DP_,91);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(F_,8) = 0;
DYNX(X_,1) = 0;
DYNX(X_,7) = 0;
DYNX(X_,0) = DYNX(DP_,14);
 /* Linear system of equations to solve. */
DYNX(W_,582) = 0.0;
SolveScalarLinearParametric( -DYNX(W_,491)," -chi.simMot.VFD.I.k", 0.0,"0.0", 
  DYNX(W_,582),"chi.simMot.VFD.addI.y");
 /* End of Equation Block */ 

DYNX(W_,502) = DYNX(DP_,18)+(IF LessTime(DYNX(DP_,19), 0) THEN 0 ELSE 
  DYNX(DP_,17));
 /* Linear system of equations to solve. */
DYNX(W_,581) = 0.0;
SolveScalarLinearParametric( -DYNX(DP_,101)," -chi.simMot.VFD.addI.k3", 
  DYNX(W_,481)*DYNX(W_,502)+DYNX(W_,482)*DYNX(X_,0)-DYNX(W_,582),
  "chi.simMot.VFD.addI.k1*chi.simMot.VFD.addI.u1+chi.simMot.VFD.addI.k2*chi.simMot.VFD.addI.u2-chi.simMot.VFD.addI.y",
   DYNX(W_,581),"chi.simMot.VFD.addI.u3");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
DYNX(W_,583) = 0.0;
SolveScalarLinearParametric( -DYNX(W_,486)," -chi.simMot.VFD.gainTrack.k",  -
  DYNX(W_,581)," -chi.simMot.VFD.gainTrack.y", DYNX(W_,583),"chi.simMot.VFD.addSat.y");
 /* End of Equation Block */ 


{ /* Non-linear system of equations to solve. */
/* Tag: initialization.nonlinear[1] */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 0 are reals, 0 are integers, and 1
   are booleans. */
const char*const varnames_[]={"chi.simMot.VFD.gainPID.y"};
const double nominal_[]={1.0};
NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 0, 1, -2, 
  DYNX(DYNhelp,12), 35, DYNX(did_->helpvari_vec,0), 23);
SetInitVectorSimple(x__, 1, DYNX(W_,584), 0, 0.0);
Residues;
  DYNX(DYNhelp,47) = DYNX(W_,584) > DYNX(W_,487);
  DYNX(W_,576) = IF DYNX(DYNhelp,47) THEN DYNX(W_,487) ELSE IF DYNX(W_,584) < 
    DYNX(W_,488) THEN DYNX(W_,488) ELSE DYNX(W_,584);
SetVector(residue__, 1, DYNX(W_,583)-DYNX(W_,576)+DYNX(W_,584));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1, 1.0-(IF DYNX(DYNhelp,47) THEN 0.0 ELSE IF 
  DYNX(W_,584) < DYNX(W_,488) THEN 0.0 ELSE 1.0));

SolveNonLinearSystemOfEquationsInit(Jacobian__, 0, 0, 0, residue__, x__,"Tag: initialization.nonlinear[1]");
DYNX(W_,584) = GetVector(x__, 1);
EndNonLinearSystemOfEquationsInit(residue__, x__, 1);
DYNNonlinearSolverStatistics(0, DYNX(W_,585), DYNX(W_,586), DYNX(W_,587), 
  DYNX(W_,588));
 /* End of Non-Linear Equation Block */ }



 /* Linear system of equations to solve. */
DYNX(W_,580) = 0.0;
SolveScalarLinearParametric( -DYNX(W_,485)," -chi.simMot.VFD.gainPID.k",  -
  DYNX(W_,584)," -chi.simMot.VFD.gainPID.y", DYNX(W_,580),"chi.simMot.VFD.addPID.y");
 /* End of Equation Block */ 

DYNX(W_,578) = DYNX(W_,468)*DYNX(W_,502)+DYNX(W_,469)*DYNX(X_,0);
DYNX(W_,579) = DYNX(DP_,100)*DYNX(W_,578);
DYNX(X_,8) = DYNX(W_,580)-DYNX(W_,579);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(3);
DYNX(X_,6) = DYNX(DP_,91);
DYNX(X_,4) = DYNX(DP_,86);
DYNX(X_,3) = DYNX(DP_,84);
DYNX(X_,5) = DYNX(DP_,89);
DYNX(X_,2) = DYNX(DP_,82);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
InitialSection2
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, sou1.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays13, 1, 1), true, true, RealTemporaryDense( &DYNX(W_,7), 1, 1), 
  "Boundary_pT"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, sou2.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays13, 1, 1), true, true, RealTemporaryDense( &DYNX(W_,18), 1, 1), 
  "Boundary_pT"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, sin2.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays13, 1, 1), true, true, RealTemporaryDense( &DYNX(W_,50), 1, 1), 
  "Boundary_pT"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, sin1.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays13, 1, 1), true, true, RealTemporaryDense( &DYNX(W_,62), 1, 1), 
  "Boundary_pT"));
PopAllMarks();
  AssertModelica(true,"true", StringAdd(StringAdd("The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.\n You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.\n Received tau = ",
    Real2String2(DYNX(W_,177), true, 0)),"\n"));
  AssertModelica4(true,"true", "In Chiller.chi.mecChi.chi.con: The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
     1,DYNX(did_->helpvari_vec,23), 0);
  AssertModelica(true,"true", StringAdd(StringAdd("The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.\n You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.\n Received tau = ",
    Real2String2(DYNX(W_,272), true, 0)),"\n"));
  AssertModelica4(true,"true", "In Chiller.chi.mecChi.chi.eva: The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
     1,DYNX(did_->helpvari_vec,24), 0);
AssertModelica(fabs((PushModelContext(1,"Buildings.Utilities.Math.Functions.polynomial(1, chi.mecChi.chi.a)")
  Buildings_Utilities_Math_Functions_polynomial(1, RealTemporaryDense( 
  &DYNX(W_,145), 1, 1)))-1) < 0.01,"abs(Buildings.Utilities.Math.Functions.polynomial(1, chi.mecChi.chi.a)-1) < 0.01",
   "Efficiency curve is wrong. Need etaPL(y=1)=1.");
PopAllMarks();
EndInitialSection

OutputSection

DynamicsSection
DYNX(W_,502) = DYNX(DP_,18)+(IF LessTime(DYNX(DP_,19), 0) THEN 0 ELSE 
  DYNX(DP_,17));
DYNX(W_,578) = DYNX(W_,468)*DYNX(W_,502)+DYNX(W_,469)*DYNX(X_,0);
DYNX(W_,579) = DYNX(DP_,100)*DYNX(W_,578);
DYNX(W_,580) = DYNX(W_,579)+DYNX(X_,8);
DYNX(W_,584) = DYNX(W_,485)*DYNX(W_,580);
DYNX(W_,576) = IF DYNX(W_,584) > DYNX(W_,487) THEN DYNX(W_,487) ELSE IF 
  DYNX(W_,584) < DYNX(W_,488) THEN DYNX(W_,488) ELSE DYNX(W_,584);
DYNX(W_,583) = DYNX(W_,576)-DYNX(W_,584);
DYNX(W_,581) = DYNX(W_,486)*DYNX(W_,583);
DYNX(W_,582) = DYNX(W_,481)*DYNX(W_,502)+DYNX(W_,482)*DYNX(X_,0)+DYNX(DP_,101)*
  DYNX(W_,581);
DYNX(F_,8) = DYNX(W_,491)*DYNX(W_,582);
DYNX(W_,561) = 0.75*(DYNX(X_,5)*DYNX(X_,4)-DYNX(X_,6)*DYNX(X_,3))*DYNX(W_,446)*
  DYNX(W_,447);
DYNX(W_,549) = 9.549296585513721*DYNX(X_,1);
DYNX(W_,550) = DYNX(W_,362)*DYNX(W_,549);
DYNX(W_,544) = DYNX(W_,550)*DYNX(W_,550)*DYNX(W_,550);
DYNX(W_,552) = 10000.0*DYNX(W_,544);
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 3 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,48) = DYNX(X_,1)-1E-06;
DYNX(W_,526) = RememberSimple_(DYNX(W_,526), 0);
SolveScalarLinear( -(IF DYNX(DYNhelp,48) > 1E-08 THEN DYNX(X_,1) ELSE IF 
  DYNX(DYNhelp,48) < -1E-08 THEN 1E-06 ELSE 5E-07+25000000.0*DYNX(DYNhelp,48)*(
  sqr(100000000.0*DYNX(DYNhelp,48))-3)*(1E-06-DYNX(X_,1))+0.5*DYNX(X_,1)),
  " -smooth(1, smooth(1, (if noEvent(der(chi.mecChi.spe.flange.phi)-1E-06 > 1E-08) then der(chi.mecChi.spe.flange.phi) else (if noEvent(der(chi.mecChi.spe.flange.phi)-1E-06 < -1E-08) then 1E-06 else 5E-07+25000000.0*((der(chi.mecChi.spe.flange.phi)-1E-06)*((100000000.0*(der(chi.mecChi.spe.flange.phi)-1E-06))^2-3)*(1E-06-der(chi.mecChi.spe.flange.phi)))+0.5*der(chi.mecChi.spe.flange.phi)))))",
    -DYNX(W_,552)," -chi.mecChi.chi.P", DYNX(W_,526),"chi.mecChi.tauChi");
 /* End of Equation Block */ 


 /* Linear system of equations to solve. */
/* Tag: simulation.linear[1] */
/* Introducing 1 common subexpressions used in 2 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,49) = DYNX(W_,385)*DYNX(DP_,80);
DYNX(F_,1) = RememberSimple_(DYNX(F_,1), 1);
SolveScalarLinearParametric(1.0+DYNX(DYNhelp,49)*DYNX(W_,356),"1.0+chi.simMot.speBlo.gain.k*chi.simMot.speBlo.integrator.k*chi.mecChi.ine.J",
   DYNX(DYNhelp,49)*DYNX(W_,561)-DYNX(DYNhelp,49)*DYNX(W_,526),"chi.simMot.speBlo.gain.k*chi.simMot.speBlo.integrator.k*chi.simMot.speBlo.feedback.u1-chi.simMot.speBlo.gain.k*chi.simMot.speBlo.integrator.k*( -chi.mecChi.ine.flange_a.tau)",
   DYNX(F_,1),"der(chi.mecChi.ine.w)");
DYNX(W_,547) = DYNX(W_,356)*DYNX(F_,1)+DYNX(W_,526);
DYNX(W_,565) = DYNX(W_,561)-DYNX(W_,547);
DYNX(W_,566) = DYNX(W_,385)*DYNX(W_,565);
 /* End of Equation Block */ 

DYNX(W_,504) = divGuarded(DYNX(W_,502)*DYNX(DP_,69),"chi.simMot.setPoi*chi.simMot.per.P",120
  *DYNX(DP_,76),"120*chi.simMot.per.Freq");
DYNX(W_,557) = IF DYNX(DP_,78) THEN DYNX(W_,576) ELSE DYNX(W_,504);
DYNX(W_,572) = DYNX(W_,380)*DYNX(W_,557);
  DYNX(W_,573) = DYNX(W_,572);
DYNX(W_,562) = DYNX(W_,557)*DYNX(W_,381);
DYNX(W_,563) = DYNX(W_,562)-DYNX(X_,1);
DYNX(W_,574) = DYNX(W_,557)*DYNX(W_,382);
  DYNX(W_,575) = 6.283185307179586*DYNX(W_,574);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[2] */
/* Introducing 8 common subexpressions used in 9 expressions */
/* Of the common subexpressions 8 are reals, 0 are integers, and 0
   are booleans. */
if (NewParameters_) {
DYNX(DYNhelp,50) = divinvGuarded(DYNX(W_,440),"chi.simMot.torSpe.motMod.i_ds_block.Ls");
}
if (NewParameters_) {
DYNX(DYNhelp,51) = divinvGuarded(DYNX(W_,418),"chi.simMot.torSpe.motMod.i_dr_block.Lr");
}
DYNX(DYNhelp,52) = DYNX(W_,439)*DYNX(X_,6);
DYNX(DYNhelp,53) = DYNX(DP_,87)-DYNX(W_,419)*DYNX(X_,4);
DYNX(DYNhelp,54) = DYNX(DYNhelp,51)*DYNX(DYNhelp,53);
DYNX(DYNhelp,55) = DYNX(W_,563)*DYNX(X_,3);
DYNX(DYNhelp,56) = DYNX(W_,563)*DYNX(W_,420)*DYNX(X_,5);
DYNX(DYNhelp,57) = DYNX(DYNhelp,51)*DYNX(DYNhelp,56);
DYNX(W_,570) = RememberSimple_(DYNX(W_,570), 2);
SolveScalarLinearParametric(1.0-DYNX(DYNhelp,51)*DYNX(DYNhelp,50)*DYNX(W_,438)*
  DYNX(W_,420),"1.0-chi.simMot.torSpe.motMod.i_ds_block.Lm*chi.simMot.torSpe.motMod.i_dr_block.Lm/chi.simMot.torSpe.motMod.i_ds_block.Ls/chi.simMot.torSpe.motMod.i_dr_block.Lr",
   DYNX(DYNhelp,50)*(DYNX(W_,573)-DYNX(DYNhelp,52))+DYNX(W_,575)*DYNX(X_,5)+
  DYNX(DYNhelp,50)*DYNX(W_,575)*DYNX(W_,438)*DYNX(X_,3)-DYNX(DYNhelp,50)*
  DYNX(W_,438)*(DYNX(DYNhelp,54)+DYNX(DYNhelp,55)+DYNX(DYNhelp,57)),
  "(chi.simMot.torSpe.motMod.i_ds_block.v_ds-chi.simMot.torSpe.motMod.i_ds_block.Rs*chi.simMot.torSpe.motMod.i_ds_block.i_ds)/chi.simMot.torSpe.motMod.i_ds_block.Ls+chi.simMot.torSpe.motMod.i_ds_block.omega*chi.simMot.torSpe.motMod.i_ds_block.i_qs+chi.simMot.torSpe.motMod.i_ds_block.omega*chi.simMot.torSpe.motMod.i_ds_block.Lm*chi.simMot.torSpe.motMod.i_ds_block.i_qr/chi.simMot.torSpe.motMod.i_ds_...",
   DYNX(W_,570),"chi.simMot.torSpe.motMod.i_dr_block.der_i_ds");
DYNX(W_,571) = DYNX(DYNhelp,51)*(DYNX(DYNhelp,53)-DYNX(W_,570)*DYNX(W_,420))+
  DYNX(DYNhelp,55)+DYNX(DYNhelp,57);
 /* End of Equation Block */ 

DYNX(F_,6) = DYNX(DP_,90)*DYNX(W_,570);
DYNX(F_,4) = DYNX(DP_,85)*DYNX(W_,571);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[3] */
/* Introducing 8 common subexpressions used in 9 expressions */
/* Of the common subexpressions 8 are reals, 0 are integers, and 0
   are booleans. */
if (NewParameters_) {
DYNX(DYNhelp,58) = divinvGuarded(DYNX(W_,430),"chi.simMot.torSpe.motMod.i_qs_block.Ls");
}
if (NewParameters_) {
DYNX(DYNhelp,59) = divinvGuarded(DYNX(W_,410),"chi.simMot.torSpe.motMod.i_qr_block.Lr");
}
DYNX(DYNhelp,60) = DYNX(W_,429)*DYNX(X_,5);
DYNX(DYNhelp,61) = DYNX(DP_,92)-DYNX(W_,411)*DYNX(X_,3);
DYNX(DYNhelp,62) = DYNX(DYNhelp,59)*DYNX(DYNhelp,61);
DYNX(DYNhelp,63) = DYNX(W_,563)*DYNX(X_,4);
DYNX(DYNhelp,64) = DYNX(W_,563)*DYNX(W_,412)*DYNX(X_,6);
DYNX(DYNhelp,65) = DYNX(DYNhelp,59)*DYNX(DYNhelp,64);
DYNX(W_,568) = RememberSimple_(DYNX(W_,568), 3);
SolveScalarLinearParametric(1.0-DYNX(DYNhelp,59)*DYNX(DYNhelp,58)*DYNX(W_,428)*
  DYNX(W_,412),"1.0-chi.simMot.torSpe.motMod.i_qs_block.Lm*chi.simMot.torSpe.motMod.i_qr_block.Lm/chi.simMot.torSpe.motMod.i_qs_block.Ls/chi.simMot.torSpe.motMod.i_qr_block.Lr",
    -(DYNX(W_,575)*DYNX(X_,6)-DYNX(DYNhelp,58)*(DYNX(W_,449)-DYNX(DYNhelp,60))+
  DYNX(DYNhelp,58)*DYNX(W_,575)*DYNX(W_,428)*DYNX(X_,4)+DYNX(DYNhelp,58)*
  DYNX(W_,428)*(DYNX(DYNhelp,62)-DYNX(DYNhelp,63)-DYNX(DYNhelp,65))),
  " -(chi.simMot.torSpe.motMod.i_qs_block.omega*chi.simMot.torSpe.motMod.i_qs_block.i_ds-(chi.simMot.torSpe.motMod.i_qs_block.v_qs-chi.simMot.torSpe.motMod.i_qs_block.Rs*chi.simMot.torSpe.motMod.i_qs_block.i_qs)/chi.simMot.torSpe.motMod.i_qs_block.Ls+chi.simMot.torSpe.motMod.i_qs_block.omega*chi.simMot.torSpe.motMod.i_qs_block.Lm*chi.simMot.torSpe.motMod.i_qs_block.i_dr/chi.simMot.torSpe.motMod.i_...",
   DYNX(W_,568),"chi.simMot.torSpe.motMod.i_qr_block.der_i_qs");
DYNX(W_,569) = DYNX(DYNhelp,59)*(DYNX(DYNhelp,61)-DYNX(W_,568)*DYNX(W_,412))-
  DYNX(DYNhelp,63)-DYNX(DYNhelp,65);
 /* End of Equation Block */ 

DYNX(F_,3) = DYNX(DP_,83)*DYNX(W_,569);
DYNX(F_,5) = DYNX(DP_,88)*DYNX(W_,568);
DYNX(F_,7) = DYNX(X_,1);
DYNX(W_,508) = DYNX(DP_,104)+(IF LessTime(DYNX(DP_,105), 1) THEN 0 ELSE IF 
  LessTime(DYNX(DP_,105)+DYNX(DP_,103), 2) THEN divGuarded((DYNTime-
  DYNX(DP_,105))*DYNX(DP_,102),"(time-TEva_in.startTime)*TEva_in.height",
  DYNX(DP_,103),"TEva_in.duration") ELSE DYNX(DP_,102));
DYNX(W_,507) = 4184*(DYNX(W_,508)-273.15);
DYNX(W_,506) = DYNX(DP_,7)+(IF LessTime(DYNX(DP_,8), 3) THEN 0 ELSE IF LessTime(
  DYNX(DP_,8)+DYNX(DP_,6), 4) THEN divGuarded((DYNTime-DYNX(DP_,8))*DYNX(DP_,5),
  "(time-TCon_in.startTime)*TCon_in.height",DYNX(DP_,6),"TCon_in.duration")
   ELSE DYNX(DP_,5));
DYNX(W_,505) = 4184*(DYNX(W_,506)-273.15);

{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[1] */
/* Introducing 11 common subexpressions used in 11 expressions */
/* Of the common subexpressions 10 are reals, 0 are integers, and 1
   are booleans. */
const char*const varnames_[]={"chi.mecChi.chi.QEva_flow_internal"};
const double nominal_[]={1.0};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 1, 0, 0, 2, 8, 3, 
  DYNX(DYNhelp,66), 41, DYNX(did_->helpvari_vec,25), 23);
NonLinearSystemSave(DYNX(W_,552), 0);
NonLinearSystemSave(DYNX(W_,505), 1);
NonLinearSystemSave(DYNX(W_,507), 2);
SetInitVectorNH(x__, 1, DYNX(W_,546), Remember_(DYNX(W_,546), 4));
Residues;
  DYNX(W_,545) = DYNX(W_,552)-DYNX(W_,546);
  DYNX(W_,540) = 1.7357474188238815E-05*DYNX(W_,545);
  DYNX(W_,551) = 57612.06896551724*DYNX(W_,540);
  DYNX(W_,520) = DYNX(W_,505)+DYNX(W_,551)*DYNX(W_,219);
  DYNX(W_,535) = 273.15+0.0002390057361376673*DYNX(W_,520);
  DYNX(W_,532) = DYNX(W_,535)+3.471494837647763E-05*DYNX(W_,551);
  DYNX(W_,543) = (-2.100307803729857E-05)*DYNX(W_,546);
  DYNX(W_,553) = (-47612.06896551724)*DYNX(W_,543);
  DYNX(W_,516) = DYNX(W_,507)+DYNX(W_,553)*DYNX(W_,314);
  DYNX(W_,537) = 273.15+0.0002390057361376673*DYNX(W_,516);
  DYNX(W_,533) = DYNX(W_,537)+4.200615607459714E-05*DYNX(W_,553);
  DYNX(DYNhelp,107) = 1+DYNX(W_,533)-DYNX(W_,532);
  DYNX(DYNhelp,108) = DYNX(DYNhelp,107) > 0.25;
  DYNX(DYNhelp,109) = IF DYNX(DYNhelp,108) THEN 1 ELSE IF DYNX(DYNhelp,107) < 
    -0.25 THEN DYNX(W_,532)-DYNX(W_,533) ELSE 0.5+0.25*(4.0+4.0*(DYNX(W_,533)-
    DYNX(W_,532)))*(sqr(4.0+4.0*(DYNX(W_,533)-DYNX(W_,532)))-3)*(DYNX(W_,532)-
    DYNX(W_,533)-1)+0.5*(DYNX(W_,532)-DYNX(W_,533));
  DYNX(DYNhelp,110) = divinvGuarded(DYNX(DYNhelp,109),"smooth(1, smooth(1, (if noEvent(1+chi.mecChi.chi.TEvaAct-chi.mecChi.chi.TConAct > 0.25) then 1 else (if noEvent(1+chi.mecChi.chi.TEvaAct-chi.mecChi.chi.TConAct < -0.25) then chi.mecChi.chi.TConAct-chi.mecChi.chi.TEvaAct else 0.5+0.25*((4.0+4.0*(chi.mecChi.chi.TEvaAct-chi.mecChi.chi.TConAct))*((4.0+4.0*(chi.mecChi.chi.TEvaAct-chi.mecChi.chi.TConAct))^2-3)*(chi.mecChi.chi.TConAct-chi.mecChi.chi.T...");
  DYNX(W_,531) = DYNX(DYNhelp,110)*DYNX(W_,533);
  DYNX(W_,530) = 0.5*DYNX(W_,531);
SetVector(residue__, 1, DYNX(W_,546)+DYNX(W_,530)*DYNX(W_,552));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
DYNX(DYNhelp,111) = sqr(DYNX(DYNhelp,109));
DYNX(DYNhelp,112) = divinvGuarded(DYNX(DYNhelp,111),"smooth(1, smooth(1, (if noEvent(1+chi.mecChi.chi.TEvaAct-chi.mecChi.chi.TConAct > 0.25) then 1 else (if noEvent(1+chi.mecChi.chi.TEvaAct-chi.mecChi.chi.TConAct < -0.25) then chi.mecChi.chi.TConAct-chi.mecChi.chi.TEvaAct else 0.5+0.25*((4.0+4.0*(chi.mecChi.chi.TEvaAct-chi.mecChi.chi.TConAct))*((4.0+4.0*(chi.mecChi.chi.TEvaAct-chi.mecChi.chi.TConAct))^2-3)*(chi.mecChi.chi.TConAct-chi.mecChi.chi.T...");
DYNX(DYNhelp,113) = (DYNX(DYNhelp,110)-DYNX(DYNhelp,112)*DYNX(W_,533)*(IF 
  DYNX(DYNhelp,108) THEN 0.0 ELSE IF DYNX(DYNhelp,107) < -0.25 THEN -1.0 ELSE 
  0.25*((DYNX(W_,532)-DYNX(W_,533)-1)*(4.0*(sqr(4.0+4.0*(DYNX(W_,533)-
  DYNX(W_,532)))-3)+(4.0+4.0*(DYNX(W_,533)-DYNX(W_,532)))*(32.0+32.0*(
  DYNX(W_,533)-DYNX(W_,532))))-(4.0+4.0*(DYNX(W_,533)-DYNX(W_,532)))*(sqr(4.0+
  4.0*(DYNX(W_,533)-DYNX(W_,532)))-3))-0.5))*DYNX(W_,552);
DYNX(DYNhelp,114) = DYNX(W_,314)*DYNX(DYNhelp,113);
DYNX(DYNhelp,115) = DYNX(W_,533)*(IF DYNX(DYNhelp,108) THEN 0.0 ELSE IF 
  DYNX(DYNhelp,107) < -0.25 THEN 1.0 ELSE 0.5+0.25*((DYNX(W_,532)-DYNX(W_,533)-1)
  *((4.0+4.0*(DYNX(W_,533)-DYNX(W_,532)))*((-32.0)-32.0*(DYNX(W_,533)-
  DYNX(W_,532)))-4.0*(sqr(4.0+4.0*(DYNX(W_,533)-DYNX(W_,532)))-3))+(4.0+4.0*(
  DYNX(W_,533)-DYNX(W_,532)))*(sqr(4.0+4.0*(DYNX(W_,533)-DYNX(W_,532)))-3)))*
  DYNX(W_,552);
DYNX(DYNhelp,116) = 0.00011950286806883365*DYNX(W_,219)*DYNX(DYNhelp,115);
DYNX(DYNhelp,117) = 1.7357474188238815E-05*DYNX(DYNhelp,115);
SetMatrixLeading(Jacobian__, 1, 1, 1, 1.0+0.9999999999999999*(0.00011950286806883365
  *DYNX(DYNhelp,114)+2.100307803729857E-05*DYNX(DYNhelp,113))-DYNX(DYNhelp,112)*
  (-1.0)*(DYNX(DYNhelp,116)+DYNX(DYNhelp,117)));

SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 2, 
  "Tag: simulation.nonlinear[1]");
DYNX(W_,546) = GetVector(x__, 1);
EndNonLinearSystemOfEquationsNH(residue__, x__, 2);
DYNNonlinearSolverStatistics(1, DYNX(W_,589), DYNX(W_,590), DYNX(W_,591), 
  DYNX(W_,592));
 /* End of Non-Linear Equation Block */ }



DYNX(W_,518) = 273.15+0.0002390057361376673*DYNX(W_,516);
DYNX(W_,517) = IF DYNX(W_,23) > DYNX(W_,36) THEN DYNX(W_,518) ELSE IF 
  DYNX(W_,23) <  -DYNX(W_,36) THEN DYNX(W_,46) ELSE IF DYNX(W_,36) > 0 THEN 
  divGuarded(0.25*DYNX(W_,23)*(sqr(divGuarded(DYNX(W_,23),"senTem.port_a.m_flow",
  DYNX(W_,36),"senTem.m_flow_small"))-3)*(DYNX(W_,46)-DYNX(W_,518)),
  "0.25*(senTem.port_a.m_flow*((senTem.port_a.m_flow/senTem.m_flow_small)^2-3)*(senTem.T_b_inflow-senTem.T_a_inflow))",
  DYNX(W_,36),"senTem.m_flow_small")+0.5*(DYNX(W_,518)+DYNX(W_,46)) ELSE 0.5*(
  DYNX(W_,518)+DYNX(W_,46));
DYNX(F_,0) = (DYNX(W_,517)-DYNX(X_,0))*DYNX(W_,39);
DYNX(W_,567) = DYNX(W_,557)*DYNX(W_,381);
DYNX(F_,2) = DYNX(DP_,81)*DYNX(W_,567);
AssertModelica(fabs(DYNX(W_,551)) < 836800.0*RealBmax(1.3769614953517503E-07, 
  fabs(DYNX(W_,12))),"noEvent(abs(chi.mecChi.chi.con.vol.steBal.Q_flow) < 836800.0*max(1.3769614953517503E-07, abs(chi.mecChi.chi.con.vol.steBal.m_flow)))",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("In Chiller.chi.mecChi.chi.con.vol.steBal:\n   The heat flow rate equals ",
  Real2String2(DYNX(W_,551), true, 0))," W and the mass flow rate equals "),
  Real2String2(DYNX(W_,12), true, 0))," kg/s,\n   which results in a temperature difference "),
  Real2String2(divGuarded(fabs(DYNX(W_,551)),"abs(chi.mecChi.chi.con.vol.steBal.Q_flow)",
  4184.0*RealBmax(1.3769614953517503E-07, fabs(DYNX(W_,12))),"4184.0*max(1.3769614953517503E-07, abs(chi.mecChi.chi.con.vol.steBal.m_flow))"),
   true, 0))," K > dTMax="),"200")," K.\n   This may indicate that energy is not conserved for small mass flow rates.\n   The implementation may require prescribedHeatFlowRate = false."));
AssertModelica(fabs(DYNX(W_,553)) < 836800.0*RealBmax(1.137955759214083E-07, 
  fabs(DYNX(W_,23))),"noEvent(abs(chi.mecChi.chi.eva.vol.steBal.Q_flow) < 836800.0*max(1.137955759214083E-07, abs(chi.mecChi.chi.eva.vol.steBal.m_flow)))",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("In Chiller.chi.mecChi.chi.eva.vol.steBal:\n   The heat flow rate equals ",
  Real2String2(DYNX(W_,553), true, 0))," W and the mass flow rate equals "),
  Real2String2(DYNX(W_,23), true, 0))," kg/s,\n   which results in a temperature difference "),
  Real2String2(divGuarded(fabs(DYNX(W_,553)),"abs(chi.mecChi.chi.eva.vol.steBal.Q_flow)",
  4184.0*RealBmax(1.137955759214083E-07, fabs(DYNX(W_,23))),"4184.0*max(1.137955759214083E-07, abs(chi.mecChi.chi.eva.vol.steBal.m_flow))"),
   true, 0))," K > dTMax="),"200")," K.\n   This may indicate that energy is not conserved for small mass flow rates.\n   The implementation may require prescribedHeatFlowRate = false."));

AcceptedSection1

AcceptedSection2
DYNX(W_,548) = DYNX(X_,7);
DYNX(Aux_,18) = DYNX(W_,507);
DYNX(Aux_,16) = DYNX(W_,505);
DYNX(Aux_,0) = DYNX(W_,505);
DYNX(Aux_,2) = DYNX(W_,507);
DYNX(Aux_,4) = DYNX(W_,505);
DYNX(Aux_,6) = DYNX(W_,507);
DYNX(Aux_,8) = DYNX(W_,505);
DYNX(Aux_,11) = DYNX(W_,505);
DYNX(Aux_,12) = DYNX(W_,507);
DYNX(Aux_,15) = DYNX(W_,507);
DYNX(W_,556) = 6.283185307179586*DYNX(W_,29)*DYNTime;
DYNX(W_,509) = (-0.8164965809277261)*DYNX(X_,6);
DYNX(W_,510) = (-0.8164965809277261)*DYNX(X_,5);
DYNX(W_,511) =  -(DYNX(W_,25)*DYNX(W_,509)+DYNX(W_,26)*DYNX(W_,510));
DYNX(W_,515) = DYNX(W_,26)*DYNX(W_,509)-DYNX(W_,25)*DYNX(W_,510);
DYNX(W_,512) = divGuarded(sqr(DYNX(W_,515))+sqr(DYNX(W_,511)),"Sou.sou.S[2]^2+( -Sou.sou.S[1])^2",
  powGuarded(0.0001+(sqr(DYNX(W_,515))+sqr(DYNX(W_,511)))*(sqr(DYNX(W_,515))+
  sqr(DYNX(W_,511))),"0.0001+(Sou.sou.S[2]^2+( -Sou.sou.S[1])^2)*(Sou.sou.S[2]^2+( -Sou.sou.S[1])^2)",
  0.25,"0.25"),"(0.0001+(Sou.sou.S[2]^2+( -Sou.sou.S[1])^2)*(Sou.sou.S[2]^2+( -Sou.sou.S[1])^2))^0.25");
if (NewParameters_) {
DYNX(DYNhelp,118) = atan2(DYNX(W_,26), DYNX(W_,25));
}
DYNX(DYNhelp,119) = atan2( -DYNX(W_,510),  -DYNX(W_,509));
DYNX(W_,513) = DYNX(DYNhelp,118)-DYNX(DYNhelp,119);
DYNX(W_,514) = cos(DYNX(W_,513));
DYNX(W_,519) = DYNX(Aux_,17)-DYNX(W_,551)*DYNX(W_,219);
DYNX(W_,521) = DYNX(Aux_,19)-DYNX(W_,553)*DYNX(W_,314);
DYNX(W_,522) = 273.15+0.0002390057361376673*DYNX(W_,505);
DYNX(W_,523) = 273.15+0.0002390057361376673*DYNX(W_,507);
DYNX(W_,524) = 273.15+0.0002390057361376673*DYNX(W_,505);
DYNX(W_,525) = 273.15+0.0002390057361376673*DYNX(W_,507);
DYNX(W_,527) = 273.15+0.0002390057361376673*DYNX(W_,505);
DYNX(W_,528) = 273.15+0.0002390057361376673*DYNX(W_,507);
DYNX(W_,529) = (-2.100307803729857E-05)*DYNX(W_,553);
DYNX(W_,534) = 273.15+0.0002390057361376673*DYNX(W_,505);
DYNX(W_,536) = 273.15+0.0002390057361376673*DYNX(W_,507);
DYNX(W_,539) = IF DYNX(W_,12) > 1.3769614953517503E-07 THEN DYNX(W_,520) ELSE 
  IF DYNX(W_,12) < -1.3769614953517503E-07 THEN DYNX(W_,519) ELSE 
  1815591.8000897802*DYNX(W_,12)*(sqr(7262367.200359121*DYNX(W_,12))-3)*(
  DYNX(W_,519)-DYNX(W_,520))+0.5*(DYNX(W_,520)+DYNX(W_,519));
DYNX(W_,538) = 273.15+0.0002390057361376673*DYNX(W_,539);
DYNX(W_,542) = IF DYNX(W_,23) > 1.137955759214083E-07 THEN DYNX(W_,516) ELSE IF 
  DYNX(W_,23) < -1.137955759214083E-07 THEN DYNX(W_,521) ELSE 2196921.9627014305
  *DYNX(W_,23)*(sqr(8787687.850805722*DYNX(W_,23))-3)*(DYNX(W_,521)-DYNX(W_,516))
  +0.5*(DYNX(W_,516)+DYNX(W_,521));
DYNX(W_,541) = 273.15+0.0002390057361376673*DYNX(W_,542);
DYNX(W_,554) = sqrtGuarded(sqr(DYNX(W_,509))+sqr(DYNX(W_,510)),"( -chi.simMot.i[1])^2+( -chi.simMot.i[2])^2");
DYNX(W_,564) = DYNX(W_,392)*DYNX(X_,1);
DYNX(W_,555) = 0.10471204188481674*DYNX(W_,564)*DYNX(W_,547);
DYNX(DYNhelp,120) = sin(DYNX(X_,2));
DYNX(DYNhelp,121) = cos(DYNX(X_,2));
DYNX(W_,558) = DYNX(DYNhelp,120)*DYNX(X_,6)+DYNX(DYNhelp,121)*DYNX(X_,5);
DYNX(DYNhelp,122) = DYNX(X_,2)-2.0933;
DYNX(DYNhelp,123) = sin(DYNX(DYNhelp,122));
DYNX(DYNhelp,124) = cos(DYNX(DYNhelp,122));
DYNX(W_,559) = DYNX(DYNhelp,123)*DYNX(X_,6)+DYNX(DYNhelp,124)*DYNX(X_,5);
DYNX(DYNhelp,125) = 2.0933+DYNX(X_,2);
DYNX(DYNhelp,126) = sin(DYNX(DYNhelp,125));
DYNX(DYNhelp,127) = cos(DYNX(DYNhelp,125));
DYNX(W_,560) = DYNX(DYNhelp,126)*DYNX(X_,6)+DYNX(DYNhelp,127)*DYNX(X_,5);
DYNX(W_,577) = DYNX(W_,502)-DYNX(X_,0);
DYNX(W_,503) = DYNX(W_,455)*DYNX(W_,502);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("P_nominal", "Nominal compressor power (at y=1) [W]", 0, 10000.0,\
 0.0,0.0,0.0,0,513)
DeclareParameter("dTEva_nominal", "Temperature difference evaporator outlet-inlet [K,]",\
 0, -10, 0.0,0.0,0.0,0,560)
DeclareParameter("dTCon_nominal", "Temperature difference condenser outlet-inlet [K,]",\
 1, 10, 0.0,0.0,0.0,0,560)
DeclareParameter("COP_nominal", "Chiller COP", 2, 3, 0.0,0.0,0.0,0,560)
DeclareVariable("m2_flow_nominal", "Nominal mass flow rate at chilled water side [kg/s]",\
 1, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("m1_flow_nominal", "Nominal mass flow rate at condenser water wide [kg/s]",\
 2, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("sou1.nPorts", "Number of ports [:#(type=Integer)]", 3, 1, \
0.0,0.0,0.0,0,517)
DeclareVariable("sou1.verifyInputs", "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range [:#(type=Boolean)]",\
 4, false, 0.0,0.0,0.0,0,515)
DeclareAlias2("sou1.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", -1, 5, 12, 132)
DeclareVariable("sou1.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 5, 300000, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("sou1.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 505, 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("sou1.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 6, 3, 1.0,3.0,0.0,0,2565)
DeclareAlias2("sou1.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 "sou1.ports[1].p", 1, 5, 5, 1024)
DeclareVariable("sou1.X_in_internal[1]", "Needed to connect to conditional connector [kg/kg]",\
 7, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("sou1.use_X_in", "Get the composition (all fractions) from the input connector [:#(type=Boolean)]",\
 8, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou1.use_Xi_in", "Get the composition (independent fractions) from the input connector [:#(type=Boolean)]",\
 9, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou1.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 10, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sou1.X[1]", "Fixed value of composition [kg/kg]", 3, 1, 0.0,\
1.0,0.1,0,560)
DeclareVariable("sou1.use_m_flow_in", "Get the mass flow rate from the input connector [:#(type=Boolean)]",\
 11, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou1.m_flow", "Fixed mass flow rate going out of the fluid port [kg/s]",\
 12, 0.0, -100000.0,100000.0,1.3769614953517504,0,513)
DeclareVariable("sou1.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 13, true, 0.0,0.0,0.0,0,1539)
DeclareParameter("sou1.T", "Fixed value of temperature [K|degC]", 4, 298.15, 1.0,\
10000.0,300.0,0,560)
DeclareAlias2("sou1.T_in", "Prescribed boundary temperature [K|degC]", \
"sou1.T_in_internal", 1, 5, 506, 0)
DeclareAlias2("sou1.m_flow_in_internal", "Needed to connect to conditional connector [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 1024)
DeclareVariable("sou1.T_in_internal", "Needed to connect to conditional connector [K|degC]",\
 506, 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("sou1.h_internal", "Internal connector for enthalpy", \
"sou1.ports[1].h_outflow", 1, 5, 505, 1024)
DeclareParameter("TCon_in.height", "Height of ramps", 5, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("TCon_in.duration", "Duration of ramp (= 0.0 gives a Step) [s]",\
 6, 60, 0.0,1E+100,0.0,0,560)
DeclareAlias2("TCon_in.y", "Connector of Real output signal", "sou1.T_in_internal", 1,\
 5, 506, 0)
DeclareParameter("TCon_in.offset", "Offset of output signal y", 7, 291.15, \
0.0,0.0,0.0,0,560)
DeclareParameter("TCon_in.startTime", "Output y = offset for time < startTime [s]",\
 8, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("sou2.nPorts", "Number of ports [:#(type=Integer)]", 14, 1, \
0.0,0.0,0.0,0,517)
DeclareVariable("sou2.verifyInputs", "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range [:#(type=Boolean)]",\
 15, false, 0.0,0.0,0.0,0,515)
DeclareAlias2("sou2.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", -1, 5, 23, 132)
DeclareVariable("sou2.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 16, 300000, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("sou2.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 507, 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("sou2.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 17, 3, 1.0,3.0,0.0,0,2565)
DeclareAlias2("sou2.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 "sou2.ports[1].p", 1, 5, 16, 1024)
DeclareVariable("sou2.X_in_internal[1]", "Needed to connect to conditional connector [kg/kg]",\
 18, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("sou2.use_X_in", "Get the composition (all fractions) from the input connector [:#(type=Boolean)]",\
 19, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou2.use_Xi_in", "Get the composition (independent fractions) from the input connector [:#(type=Boolean)]",\
 20, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou2.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 21, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sou2.X[1]", "Fixed value of composition [kg/kg]", 9, 1, 0.0,\
1.0,0.1,0,560)
DeclareVariable("sou2.use_m_flow_in", "Get the mass flow rate from the input connector [:#(type=Boolean)]",\
 22, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sou2.m_flow", "Fixed mass flow rate going out of the fluid port [kg/s]",\
 23, 0.0, -100000.0,100000.0,1.137955759214083,0,513)
DeclareVariable("sou2.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 24, true, 0.0,0.0,0.0,0,1539)
DeclareParameter("sou2.T", "Fixed value of temperature [K|degC]", 10, 298.15, \
1.0,10000.0,300.0,0,560)
DeclareAlias2("sou2.T_in", "Prescribed boundary temperature [K|degC]", \
"sou2.T_in_internal", 1, 5, 508, 0)
DeclareAlias2("sou2.m_flow_in_internal", "Needed to connect to conditional connector [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 1024)
DeclareVariable("sou2.T_in_internal", "Needed to connect to conditional connector [K|degC]",\
 508, 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("sou2.h_internal", "Internal connector for enthalpy", \
"sou2.ports[1].h_outflow", 1, 5, 507, 1024)
DeclareVariable("Sou.terminal.v[1]", "Voltage vector [V]", 25, 0.0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("Sou.terminal.v[2]", "Voltage vector [V]", 26, 0.0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("Sou.terminal.i[1]", "Current vector [A]", 509, 0, 0.0,0.0,0.0,0,776)
DeclareVariable("Sou.terminal.i[2]", "Current vector [A]", 510, 0, 0.0,0.0,0.0,0,776)
DeclareAlias2("Sou.terminal.theta[1]", "Optional vector of phase angles [rad|deg]",\
 "chi.simMot.theta_s", 1, 5, 556, 4)
DeclareParameter("Sou.f", "Frequency of the source [Hz]", 11, 50, 0.0,0.0,0.0,0,560)
DeclareParameter("Sou.V", "RMS voltage of the source [V]", 12, 400, 0.0,0.0,0.0,\
0,560)
DeclareParameter("Sou.phiSou", "Phase shift angle of the source [rad|deg]", 13, 0,\
 0.0,0.0,0.0,0,560)
DeclareVariable("Sou.P.real", "Real power [W]", 511, 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("Sou.P.apparent", "Apparent power [var]", 512, 0.0, 0.0,0.0,0.0,\
0,520)
DeclareVariable("Sou.P.phi", "Phase shift [rad|deg]", 513, 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("Sou.P.cosPhi", "Power factor", 514, 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("Sou.sou.potentialReference", "Serve as potential root for the reference angle theta [:#(type=Boolean)]",\
 27, true, 0.0,0.0,0.0,0,515)
DeclareVariable("Sou.sou.definiteReference", "Serve as definite root for the reference angle theta [:#(type=Boolean)]",\
 28, true, 0.0,0.0,0.0,0,515)
DeclareAlias2("Sou.sou.S[1]", "Complex power S[1] = P, S[2]= Q [W]", \
"Sou.P.real", -1, 5, 511, 0)
DeclareVariable("Sou.sou.S[2]", "Complex power S[1] = P, S[2]= Q [W]", 515, 0.0,\
 0.0,0.0,0.0,0,512)
DeclareAlias2("Sou.sou.phi", "Phase shift with respect to reference angle [rad|deg]",\
 "Sou.P.phi", 1, 5, 513, 0)
DeclareAlias2("Sou.sou.terminal.v[1]", "Voltage vector [V]", "Sou.terminal.v[1]", 1,\
 5, 25, 4)
DeclareAlias2("Sou.sou.terminal.v[2]", "Voltage vector [V]", "Sou.terminal.v[2]", 1,\
 5, 26, 4)
DeclareAlias2("Sou.sou.terminal.i[1]", "Current vector [A]", "Sou.terminal.i[1]", 1,\
 5, 509, 132)
DeclareAlias2("Sou.sou.terminal.i[2]", "Current vector [A]", "Sou.terminal.i[2]", 1,\
 5, 510, 132)
DeclareAlias2("Sou.sou.terminal.theta[1]", "Optional vector of phase angles [rad|deg]",\
 "chi.simMot.theta_s", 1, 5, 556, 4)
DeclareVariable("Sou.sou.f", "Frequency of the source [Hz]", 29, 60, 0.0,0.0,0.0,\
0,513)
DeclareVariable("Sou.sou.V", "RMS voltage of the source [V]", 30, 480, 0.0,0.0,\
0.0,0,513)
DeclareVariable("Sou.sou.phiSou", "Phase shift of the source [rad|deg]", 31, 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("Sou.sou.thetaRel", "Absolute angle of rotating system as offset to thetaRef [rad|deg]",\
 32, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("senTem.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 33, true, 0.0,0.0,0.0,0,515)
DeclareAlias2("senTem.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 132)
DeclareAlias2("senTem.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 21, 4)
DeclareVariable("senTem.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 34, 83680.0, -10000000000.0,10000000000.0,83680.0,0,521)
DeclareAlias2("senTem.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", -1, 5, 23, 132)
DeclareAlias2("senTem.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 21, 4)
DeclareVariable("senTem.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 516, 83680.0, -10000000000.0,10000000000.0,83680.0,0,520)
DeclareVariable("senTem.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 35, 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("senTem.m_flow_small", "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 36, 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("senTem.tau", "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems) [s]",\
 37, 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("senTem.initType", "Type of initialization (InitialState and InitialOutput are identical) [:#(type=Modelica.Blocks.Types.Init)]",\
 38, 3, 1.0,4.0,0.0,0,517)
DeclareVariable("senTem.k", "Gain to take flow rate into account for sensor time constant",\
 39, 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("senTem.dynamic", "Flag, true if the sensor is a dynamic sensor [:#(type=Boolean)]",\
 40, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("senTem.mNor_flow", "Normalized mass flow rate", 41, 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("senTem.tauInv", "Inverse of tau [s-1]", 42, 1.0, 0.0,0.0,0.0,0,2561)
DeclareState("senTem.T", "Temperature of the passing fluid [K|degC]", 0, 0.0, \
0.0,1E+100,0.0,0,544)
DeclareDerivative("senTem.der(T)", "der(Temperature of the passing fluid) [K/s]",\
 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("senTem.T_start", "Initial or guess value of output (= state) [K|degC]",\
 14, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("senTem.transferHeat", "if true, temperature T converges towards TAmb when no flow [:#(type=Boolean)]",\
 43, false, 0.0,0.0,0.0,0,515)
DeclareParameter("senTem.TAmb", "Fixed ambient temperature for heat transfer [K|degC]",\
 15, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("senTem.tauHeaTra", "Time constant for heat transfer, default 20 minutes [s]",\
 16, 1200, 1.0,1E+100,0.0,0,560)
DeclareVariable("senTem.tauHeaTraInv", "Dummy parameter to avoid division by tauHeaTra [1/s]",\
 44, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("senTem.ratTau", "Ratio of tau", 45, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("senTem.TMed", "Medium temperature to which the sensor is exposed [K|degC]",\
 517, 300.0, 1.0,10000.0,300.0,0,2560)
DeclareVariable("senTem.T_a_inflow", "Temperature of inflowing fluid at port_a [K|degC]",\
 518, 293.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("senTem.T_b_inflow", "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow [K|degC]",\
 46, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareParameter("TSet.height", "Height of step", 17, -2, 0.0,0.0,0.0,0,560)
DeclareVariable("TSet.y", "Connector of Real output signal", 502, 0.0, 0.0,0.0,\
0.0,0,640)
DeclareParameter("TSet.offset", "Offset of output signal y", 18, 278.15, \
0.0,0.0,0.0,0,560)
DeclareParameter("TSet.startTime", "Output y = offset for time < startTime [s]",\
 19, 500, 0.0,0.0,0.0,0,560)
DeclareVariable("sin2.nPorts", "Number of ports [:#(type=Integer)]", 47, 1, \
0.0,0.0,0.0,0,517)
DeclareVariable("sin2.verifyInputs", "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range [:#(type=Boolean)]",\
 48, false, 0.0,0.0,0.0,0,515)
DeclareAlias2("sin2.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 132)
DeclareAlias2("sin2.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 21, 4)
DeclareAlias2("sin2.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "senTem.port_a.h_outflow", 1, 5, 34, 4)
DeclareVariable("sin2.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 49, 3, 1.0,3.0,0.0,0,2565)
DeclareAlias2("sin2.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 "sin2.p", 1, 7, 21, 1024)
DeclareVariable("sin2.X_in_internal[1]", "Needed to connect to conditional connector [kg/kg]",\
 50, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("sin2.use_X_in", "Get the composition (all fractions) from the input connector [:#(type=Boolean)]",\
 51, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sin2.use_Xi_in", "Get the composition (independent fractions) from the input connector [:#(type=Boolean)]",\
 52, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sin2.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 53, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sin2.X[1]", "Fixed value of composition [kg/kg]", 20, 1, 0.0,\
1.0,0.1,0,560)
DeclareVariable("sin2.use_p_in", "Get the pressure from the input connector [:#(type=Boolean)]",\
 54, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sin2.p", "Fixed value of pressure [Pa|bar]", 21, 300000, 0.0,\
100000000.0,100000.0,0,560)
DeclareVariable("sin2.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 55, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sin2.T", "Fixed value of temperature [K|degC]", 22, 293.15, \
1.0,10000.0,300.0,0,560)
DeclareVariable("sin2.checkWaterPressure", "Evaluates to true if the pressure should be checked [:#(type=Boolean)]",\
 56, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("sin2.checkAirPressure", "Evaluates to true if the pressure should be checked [:#(type=Boolean)]",\
 57, false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("sin2.T_in_internal", "Needed to connect to conditional connector [K|degC]",\
 "sin2.T", 1, 7, 22, 1024)
DeclareAlias2("sin2.h_internal", "Internal connector for enthalpy", \
"senTem.port_a.h_outflow", 1, 5, 34, 1024)
DeclareVariable("sin1.nPorts", "Number of ports [:#(type=Integer)]", 58, 1, \
0.0,0.0,0.0,0,517)
DeclareVariable("sin1.verifyInputs", "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range [:#(type=Boolean)]",\
 59, false, 0.0,0.0,0.0,0,515)
DeclareAlias2("sin1.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 132)
DeclareAlias2("sin1.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 24, 4)
DeclareVariable("sin1.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 60, 0.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("sin1.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 61, 3, 1.0,3.0,0.0,0,2565)
DeclareAlias2("sin1.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 "sin1.p", 1, 7, 24, 1024)
DeclareVariable("sin1.X_in_internal[1]", "Needed to connect to conditional connector [kg/kg]",\
 62, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("sin1.use_X_in", "Get the composition (all fractions) from the input connector [:#(type=Boolean)]",\
 63, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sin1.use_Xi_in", "Get the composition (independent fractions) from the input connector [:#(type=Boolean)]",\
 64, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sin1.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 65, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sin1.X[1]", "Fixed value of composition [kg/kg]", 23, 1, 0.0,\
1.0,0.1,0,560)
DeclareVariable("sin1.use_p_in", "Get the pressure from the input connector [:#(type=Boolean)]",\
 66, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sin1.p", "Fixed value of pressure [Pa|bar]", 24, 300000, 0.0,\
100000000.0,100000.0,0,560)
DeclareVariable("sin1.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 67, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sin1.T", "Fixed value of temperature [K|degC]", 25, 293.15, \
1.0,10000.0,300.0,0,560)
DeclareVariable("sin1.checkWaterPressure", "Evaluates to true if the pressure should be checked [:#(type=Boolean)]",\
 68, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("sin1.checkAirPressure", "Evaluates to true if the pressure should be checked [:#(type=Boolean)]",\
 69, false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("sin1.T_in_internal", "Needed to connect to conditional connector [K|degC]",\
 "sin1.T", 1, 7, 25, 1024)
DeclareAlias2("sin1.h_internal", "Internal connector for enthalpy", \
"sin1.ports[1].h_outflow", 1, 5, 60, 1024)
DeclareVariable("chi.allowFlowReversal1", "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1 [:#(type=Boolean)]",\
 70, true, 0.0,0.0,0.0,0,515)
DeclareVariable("chi.allowFlowReversal2", "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2 [:#(type=Boolean)]",\
 71, true, 0.0,0.0,0.0,0,515)
DeclareAlias2("chi.port_a1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 132)
DeclareAlias2("chi.port_a1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou1.ports[1].p", 1, 5, 5, 4)
DeclareVariable("chi.port_a1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 519, 83680.0, -10000000000.0,10000000000.0,83680.0,0,520)
DeclareAlias2("chi.port_b1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", -1, 5, 12, 132)
DeclareAlias2("chi.port_b1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 24, 4)
DeclareVariable("chi.port_b1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 520, 83680.0, -10000000000.0,10000000000.0,83680.0,0,520)
DeclareAlias2("chi.port_a2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 132)
DeclareAlias2("chi.port_a2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou2.ports[1].p", 1, 5, 16, 4)
DeclareVariable("chi.port_a2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 521, 83680.0, -10000000000.0,10000000000.0,83680.0,0,520)
DeclareAlias2("chi.port_b2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", -1, 5, 23, 132)
DeclareAlias2("chi.port_b2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 21, 4)
DeclareAlias2("chi.port_b2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "senTem.port_b.h_outflow", 1, 5, 516, 4)
DeclareVariable("chi.m1_flow_nominal", "Nominal mass flow rate [kg/s]", 72, \
1.3769614953517504, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.m2_flow_nominal", "Nominal mass flow rate [kg/s]", 73, \
1.137955759214083, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.m1_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 74, 0.00013769614953517505, 0.0,100000.0,0.0,0,513)
DeclareVariable("chi.m2_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 75, 0.0001137955759214083, 0.0,100000.0,0.0,0,513)
DeclareVariable("chi.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 76, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("chi.m1_flow", "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction) [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 0)
DeclareVariable("chi.dp1", "Pressure difference between port_a1 and port_b1 [Pa|Pa]",\
 77, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.m2_flow", "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction) [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 0)
DeclareVariable("chi.dp2", "Pressure difference between port_a2 and port_b2 [Pa|Pa]",\
 78, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.state_a1_inflow.p", "Absolute pressure of medium [Pa|bar]", \
"sou1.ports[1].p", 1, 5, 5, 1024)
DeclareVariable("chi.state_a1_inflow.T", "Temperature of medium [K|degC]", 522, \
293.15, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("chi.state_b1_inflow.p", "Absolute pressure of medium [Pa|bar]", \
"sin1.p", 1, 7, 24, 1024)
DeclareVariable("chi.state_b1_inflow.T", "Temperature of medium [K|degC]", 79, \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareAlias2("chi.state_a2_inflow.p", "Absolute pressure of medium [Pa|bar]", \
"sou2.ports[1].p", 1, 5, 16, 1024)
DeclareVariable("chi.state_a2_inflow.T", "Temperature of medium [K|degC]", 523, \
293.15, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("chi.state_b2_inflow.p", "Absolute pressure of medium [Pa|bar]", \
"sin2.p", 1, 7, 21, 1024)
DeclareVariable("chi.state_b2_inflow.T", "Temperature of medium [K|degC]", 80, \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareAlias2("chi.terminal.v[1]", "Voltage vector [V]", "Sou.terminal.v[1]", 1,\
 5, 25, 4)
DeclareAlias2("chi.terminal.v[2]", "Voltage vector [V]", "Sou.terminal.v[2]", 1,\
 5, 26, 4)
DeclareAlias2("chi.terminal.i[1]", "Current vector [A]", "Sou.terminal.i[1]", -1,\
 5, 509, 132)
DeclareAlias2("chi.terminal.i[2]", "Current vector [A]", "Sou.terminal.i[2]", -1,\
 5, 510, 132)
DeclareAlias2("chi.terminal.theta[1]", "Optional vector of phase angles [rad|deg]",\
 "chi.simMot.theta_s", 1, 5, 556, 4)
DeclareVariable("chi.QEva_flow_nominal", "Nominal cooling heat flow rate (Negative) [W]",\
 81, -47612.06896551724, -1E+100,0.0,0.0,0,513)
DeclareVariable("chi.QCon_flow_nominal", "Nominal heating flow rate (Positive) [W]",\
 82, 57612.06896551724, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.dTEva_nominal", "Temperature difference evaporator outlet-inlet [K,]",\
 83, -10, -1E+100,0.0,0.0,0,513)
DeclareVariable("chi.dTCon_nominal", "Temperature difference condenser outlet-inlet [K,]",\
 84, 10, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.P_nominal", "Nominal compressor power (at y=1) [W]", 85, \
10000.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("chi.Nrpm_nominal", "Nominal rotational speed of compressor [rev/min]",\
 26, 1800, 0.0,0.0,0.0,0,560)
DeclareVariable("chi.dp1_nominal", "Pressure difference over condenser [Pa|Pa]",\
 86, 1000, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.dp2_nominal", "Pressure difference over evaporator [Pa|Pa]",\
 87, 1000, 0.0,0.0,0.0,0,513)
DeclareParameter("chi.use_eta_Carnot_nominal", "Set to true to use Carnot effectiveness etaCarnot_nominal rather than COP_nominal [:#(type=Boolean)]",\
 27, true, 0.0,0.0,0.0,0,562)
DeclareVariable("chi.etaCarnot_nominal", "Carnot effectiveness (=COP/COP_Carnot) used if use_eta_Carnot_nominal = true [1]",\
 88, 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.COP_nominal", "Coefficient of performance at TEva_nominal and TCon_nominal, used if use_eta_Carnot_nominal = false [1]",\
 89, 4.761206896551724, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.TCon_nominal", "Condenser temperature used to compute COP_nominal if use_eta_Carnot_nominal=false [K|degC]",\
 90, 303.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("chi.TEva_nominal", "Evaporator temperature used to compute COP_nominal if use_eta_Carnot_nominal=false [K|degC]",\
 91, 278.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("chi.a[1]", "Coefficients for efficiency curve (need p(a=a, yPL=1)=1)",\
 92, 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.TAppCon_nominal", "Temperature difference between refrigerant and working fluid outlet in condenser [K,]",\
 93, 2, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.TAppEva_nominal", "Temperature difference between refrigerant and working fluid outlet in evaporator [K,]",\
 94, 2, 0.0,1E+100,0.0,0,513)
DeclareParameter("chi.per.P", "Number of Poles [:#(type=Integer)]", 28, 4, \
0.0,0.0,0.0,0,564)
DeclareParameter("chi.per.J", "Moment of Inertia [kg/m\302\262] []", 29, 0.0131,\
 0.0,0.0,0.0,0,560)
DeclareParameter("chi.per.Lr", "Rotor Inductance [H] []", 30, 0.178039, 0.0,0.0,\
0.0,0,560)
DeclareParameter("chi.per.Ls", "Stator Inductance [H] []", 31, 0.178039, \
0.0,0.0,0.0,0,560)
DeclareParameter("chi.per.Lm", "Mutual Inductance [H] []", 32, 0.1722, 0.0,0.0,\
0.0,0,560)
DeclareParameter("chi.per.Rs", "Stator Resistance [ohm] []", 33, 1.405, 0.0,0.0,\
0.0,0,560)
DeclareParameter("chi.per.Rr", "Rotor Resistance [ohm] []", 34, 1.395, 0.0,0.0,\
0.0,0,560)
DeclareParameter("chi.per.Freq", "Standard Frequency [Hz] []", 35, 50, 0.0,0.0,\
0.0,0,560)
DeclareParameter("chi.per.Voltage", "Standard Voltage [V] []", 36, 400, 0.0,0.0,\
0.0,0,560)
DeclareVariable("chi.P", "Number of poles [:#(type=Integer)]", 95, 0, 0.0,0.0,\
0.0,0,517)
DeclareVariable("chi.J", "Moment of inertia", 96, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("chi.Lr", "Rotor inductance [H] []", 37, 0.1458, 0.0,0.0,0.0,0,560)
DeclareParameter("chi.Ls", "Stator inductance [H] []", 38, 0.1457, 0.0,0.0,0.0,0,560)
DeclareParameter("chi.Lm", "Mutual inductance [H] []", 39, 0.1406, 0.0,0.0,0.0,0,560)
DeclareParameter("chi.Rr", "Rotor resistance [ohm] []", 40, 1.145, 0.0,0.0,0.0,0,560)
DeclareParameter("chi.Rs", "Stator resistance [ohm] []", 41, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("chi.have_controller", "Set to true for enableing PID control [:#(type=Boolean)]",\
 42, true, 0.0,0.0,0.0,0,562)
DeclareParameter("chi.controllerType", "Type of controller [:#(type=Modelica.Blocks.Types.SimpleController)]",\
 43, 2, 1.0,4.0,0.0,0,564)
DeclareParameter("chi.k", "Gain of controller", 44, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("chi.Ti", "Time constant of Integrator block [s]", 45, 0.5, \
1E-60,1E+100,0.0,0,560)
DeclareParameter("chi.Td", "Time constant of Derivative block [s]", 46, 0.1, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("chi.yMax", "Upper limit of output", 47, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("chi.yMin", "Lower limit of output", 48, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("chi.mecChi.allowFlowReversal1", "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1 [:#(type=Boolean)]",\
 97, true, 0.0,0.0,0.0,0,515)
DeclareVariable("chi.mecChi.allowFlowReversal2", "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2 [:#(type=Boolean)]",\
 98, true, 0.0,0.0,0.0,0,515)
DeclareAlias2("chi.mecChi.port_a1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 132)
DeclareAlias2("chi.mecChi.port_a1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou1.ports[1].p", 1, 5, 5, 4)
DeclareAlias2("chi.mecChi.port_a1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_a1.h_outflow", 1, 5, 519, 4)
DeclareAlias2("chi.mecChi.port_b1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", -1, 5, 12, 132)
DeclareAlias2("chi.mecChi.port_b1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 24, 4)
DeclareAlias2("chi.mecChi.port_b1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_b1.h_outflow", 1, 5, 520, 4)
DeclareAlias2("chi.mecChi.port_a2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 132)
DeclareAlias2("chi.mecChi.port_a2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou2.ports[1].p", 1, 5, 16, 4)
DeclareAlias2("chi.mecChi.port_a2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_a2.h_outflow", 1, 5, 521, 4)
DeclareAlias2("chi.mecChi.port_b2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", -1, 5, 23, 132)
DeclareAlias2("chi.mecChi.port_b2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 21, 4)
DeclareAlias2("chi.mecChi.port_b2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "senTem.port_b.h_outflow", 1, 5, 516, 4)
DeclareVariable("chi.mecChi.m1_flow_nominal", "Nominal mass flow rate [kg/s]", 99,\
 1.3769614953517504, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.m2_flow_nominal", "Nominal mass flow rate [kg/s]", 100,\
 1.137955759214083, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.m1_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 101, 0.00013769614953517505, 0.0,100000.0,0.0,0,513)
DeclareVariable("chi.mecChi.m2_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 102, 0.0001137955759214083, 0.0,100000.0,0.0,0,513)
DeclareVariable("chi.mecChi.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 103, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("chi.mecChi.m1_flow", "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction) [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 0)
DeclareVariable("chi.mecChi.dp1", "Pressure difference between port_a1 and port_b1 [Pa|Pa]",\
 104, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.mecChi.m2_flow", "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction) [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 0)
DeclareVariable("chi.mecChi.dp2", "Pressure difference between port_a2 and port_b2 [Pa|Pa]",\
 105, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.mecChi.state_a1_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "sou1.ports[1].p", 1, 5, 5, 1024)
DeclareVariable("chi.mecChi.state_a1_inflow.T", "Temperature of medium [K|degC]",\
 524, 293.15, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("chi.mecChi.state_b1_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "sin1.p", 1, 7, 24, 1024)
DeclareVariable("chi.mecChi.state_b1_inflow.T", "Temperature of medium [K|degC]",\
 106, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareAlias2("chi.mecChi.state_a2_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "sou2.ports[1].p", 1, 5, 16, 1024)
DeclareVariable("chi.mecChi.state_a2_inflow.T", "Temperature of medium [K|degC]",\
 525, 293.15, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("chi.mecChi.state_b2_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "sin2.p", 1, 7, 21, 1024)
DeclareVariable("chi.mecChi.state_b2_inflow.T", "Temperature of medium [K|degC]",\
 107, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("chi.mecChi.QEva_flow_nominal", "Nominal cooling heat flow rate (Negative) [W]",\
 108, -47612.06896551724, -1E+100,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.QCon_flow_nominal", "Nominal heating flow rate (Positive) [W]",\
 109, 57612.06896551724, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.dTEva_nominal", "Temperature difference evaporator outlet-inlet [K,]",\
 110, -10, -1E+100,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.dTCon_nominal", "Temperature difference condenser outlet-inlet [K,]",\
 111, 10, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.P_nominal", "Nominal compressor power (at y=1) [W]",\
 112, 10000.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.dp1_nominal", "Pressure difference over condenser [Pa|Pa]",\
 113, 1000, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.dp2_nominal", "Pressure difference over evaporator [Pa|Pa]",\
 114, 1000, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.Nrpm_nominal", "Nominal rotational speed of compressor [rev/min]",\
 115, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("chi.mecChi.loaIne", "Chiller inertia [kg.m2]", 49, 1, 0.0,\
1E+100,0.0,0,560)
DeclareVariable("chi.mecChi.use_eta_Carnot_nominal", "Set to true to use Carnot effectiveness etaCarnot_nominal rather than COP_nominal [:#(type=Boolean)]",\
 116, false, 0.0,0.0,0.0,0,515)
DeclareVariable("chi.mecChi.etaCarnot_nominal", "Carnot effectiveness (=COP/COP_Carnot) used if use_eta_Carnot_nominal = true [1]",\
 117, 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.COP_nominal", "Coefficient of performance at TEva_nominal and TCon_nominal, used if use_eta_Carnot_nominal = false [1]",\
 118, 4.761206896551724, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.TCon_nominal", "Condenser temperature used to compute COP_nominal if use_eta_Carnot_nominal=false [K|degC]",\
 119, 303.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("chi.mecChi.TEva_nominal", "Evaporator temperature used to compute COP_nominal if use_eta_Carnot_nominal=false [K|degC]",\
 120, 278.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("chi.mecChi.a[1]", "Coefficients for efficiency curve (need p(a=a, yPL=1)=1)",\
 121, 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.TAppCon_nominal", "Temperature difference between refrigerant and working fluid outlet in condenser [K,]",\
 122, 2, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.TAppEva_nominal", "Temperature difference between refrigerant and working fluid outlet in evaporator [K,]",\
 123, 2, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.tauChi", "Chiller torque [N.m]", 526, 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("chi.mecChi.chi.allowFlowReversal1", "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1 [:#(type=Boolean)]",\
 124, true, 0.0,0.0,0.0,0,515)
DeclareVariable("chi.mecChi.chi.allowFlowReversal2", "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2 [:#(type=Boolean)]",\
 125, true, 0.0,0.0,0.0,0,515)
DeclareAlias2("chi.mecChi.chi.port_a1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 132)
DeclareAlias2("chi.mecChi.chi.port_a1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou1.ports[1].p", 1, 5, 5, 4)
DeclareAlias2("chi.mecChi.chi.port_a1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_a1.h_outflow", 1, 5, 519, 4)
DeclareAlias2("chi.mecChi.chi.port_b1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", -1, 5, 12, 132)
DeclareAlias2("chi.mecChi.chi.port_b1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 24, 4)
DeclareAlias2("chi.mecChi.chi.port_b1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_b1.h_outflow", 1, 5, 520, 4)
DeclareAlias2("chi.mecChi.chi.port_a2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 132)
DeclareAlias2("chi.mecChi.chi.port_a2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou2.ports[1].p", 1, 5, 16, 4)
DeclareAlias2("chi.mecChi.chi.port_a2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_a2.h_outflow", 1, 5, 521, 4)
DeclareAlias2("chi.mecChi.chi.port_b2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", -1, 5, 23, 132)
DeclareAlias2("chi.mecChi.chi.port_b2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 21, 4)
DeclareAlias2("chi.mecChi.chi.port_b2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "senTem.port_b.h_outflow", 1, 5, 516, 4)
DeclareVariable("chi.mecChi.chi.m1_flow_nominal", "Nominal mass flow rate [kg/s]",\
 126, 1.3769614953517504, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.chi.m2_flow_nominal", "Nominal mass flow rate [kg/s]",\
 127, 1.137955759214083, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.chi.m1_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 128, 0.00013769614953517505, 0.0,100000.0,0.0,0,513)
DeclareVariable("chi.mecChi.chi.m2_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 129, 0.0001137955759214083, 0.0,100000.0,0.0,0,513)
DeclareVariable("chi.mecChi.chi.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 130, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("chi.mecChi.chi.m1_flow", "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction) [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 0)
DeclareVariable("chi.mecChi.chi.dp1", "Pressure difference between port_a1 and port_b1 [Pa|Pa]",\
 131, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.mecChi.chi.m2_flow", "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction) [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 0)
DeclareVariable("chi.mecChi.chi.dp2", "Pressure difference between port_a2 and port_b2 [Pa|Pa]",\
 132, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.mecChi.chi.state_a1_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "sou1.ports[1].p", 1, 5, 5, 1024)
DeclareVariable("chi.mecChi.chi.state_a1_inflow.T", "Temperature of medium [K|degC]",\
 527, 293.15, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("chi.mecChi.chi.state_b1_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "sin1.p", 1, 7, 24, 1024)
DeclareVariable("chi.mecChi.chi.state_b1_inflow.T", "Temperature of medium [K|degC]",\
 133, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareAlias2("chi.mecChi.chi.state_a2_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "sou2.ports[1].p", 1, 5, 16, 1024)
DeclareVariable("chi.mecChi.chi.state_a2_inflow.T", "Temperature of medium [K|degC]",\
 528, 293.15, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("chi.mecChi.chi.state_b2_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "sin2.p", 1, 7, 21, 1024)
DeclareVariable("chi.mecChi.chi.state_b2_inflow.T", "Temperature of medium [K|degC]",\
 134, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("chi.mecChi.chi.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 135, true, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.mecChi.chi.QEva_flow_nominal", "Nominal cooling heat flow rate (QEva_flow_nominal < 0) [W]",\
 136, -47612.06896551724, -1E+100,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.chi.QCon_flow_nominal", "Nominal heating flow rate [W]",\
 137, 57612.06896551724, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.chi.dTEva_nominal", "Temperature difference evaporator outlet-inlet [K,]",\
 138, -10.0, -1E+100,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.chi.dTCon_nominal", "Temperature difference condenser outlet-inlet [K,]",\
 139, 10.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.chi.use_eta_Carnot_nominal", "Set to true to use Carnot effectiveness etaCarnot_nominal rather than COP_nominal [:#(type=Boolean)]",\
 140, false, 0.0,0.0,0.0,0,515)
DeclareVariable("chi.mecChi.chi.etaCarnot_nominal", "Carnot effectiveness (=COP/COP_Carnot) used during simulation if use_eta_Carnot_nominal = true [1]",\
 141, 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.chi.COP_nominal", "Coefficient of performance at TEva_nominal and TCon_nominal, used during simulation if use_eta_Carnot_nominal = false [1]",\
 142, 4.761206896551724, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.chi.TCon_nominal", "Condenser temperature used to compute COP_nominal if use_eta_Carnot_nominal=false [K|degC]",\
 143, 303.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("chi.mecChi.chi.TEva_nominal", "Evaporator temperature used to compute COP_nominal if use_eta_Carnot_nominal=false [K|degC]",\
 144, 278.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("chi.mecChi.chi.a[1]", "Coefficients for efficiency curve (need p(a=a, yPL=1)=1)",\
 145, 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.chi.dp1_nominal", "Pressure difference over condenser [Pa|Pa]",\
 146, 1000, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.chi.dp2_nominal", "Pressure difference over evaporator [Pa|Pa]",\
 147, 1000, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.chi.TAppCon_nominal", "Temperature difference between refrigerant and working fluid outlet in condenser [K,]",\
 148, 2.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.chi.TAppEva_nominal", "Temperature difference between refrigerant and working fluid outlet in evaporator [K,]",\
 149, 2.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.chi.from_dp1", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 150, false, 0.0,0.0,0.0,0,515)
DeclareVariable("chi.mecChi.chi.from_dp2", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 151, false, 0.0,0.0,0.0,0,515)
DeclareVariable("chi.mecChi.chi.linearizeFlowResistance1", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 152, false, 0.0,0.0,0.0,0,515)
DeclareVariable("chi.mecChi.chi.linearizeFlowResistance2", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 153, false, 0.0,0.0,0.0,0,515)
DeclareVariable("chi.mecChi.chi.deltaM1", "Fraction of nominal flow rate where flow transitions to laminar [1]",\
 154, 0.1, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.chi.deltaM2", "Fraction of nominal flow rate where flow transitions to laminar [1]",\
 155, 0.1, 0.0,0.0,0.0,0,513)
DeclareParameter("chi.mecChi.chi.tau1", "Time constant at nominal flow rate (used if energyDynamics1 <> Modelica.Fluid.Types.Dynamics.SteadyState) [s]",\
 50, 60, 0.0,0.0,0.0,0,560)
DeclareParameter("chi.mecChi.chi.tau2", "Time constant at nominal flow rate (used if energyDynamics2 <> Modelica.Fluid.Types.Dynamics.SteadyState) [s]",\
 51, 60, 0.0,0.0,0.0,0,560)
DeclareParameter("chi.mecChi.chi.T1_start", "Initial or guess value of set point [K|degC]",\
 52, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("chi.mecChi.chi.T2_start", "Initial or guess value of set point [K|degC]",\
 53, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("chi.mecChi.chi.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 156, 4, 1.0,4.0,0.0,0,517)
DeclareAlias2("chi.mecChi.chi.QCon_flow", "Actual heating heat flow rate added to fluid 1 [W]",\
 "chi.mecChi.QCon_flow", 1, 5, 551, 0)
DeclareAlias2("chi.mecChi.chi.P", "Electric power consumed by compressor [W]", \
"chi.mecChi.P", 1, 5, 552, 0)
DeclareAlias2("chi.mecChi.chi.QEva_flow", "Actual cooling heat flow rate removed from fluid 2 [W]",\
 "chi.mecChi.QEva_flow", 1, 5, 553, 0)
DeclareVariable("chi.mecChi.chi.yPL", "Part load ratio [1]", 529, 0.0, 0.0,\
1E+100,0.0,0,512)
DeclareVariable("chi.mecChi.chi.etaPL", "Efficiency due to part load (etaPL(yPL=1)=1) [1]",\
 157, 1, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.mecChi.chi.COP", "Coefficient of performance [1]", 530, 0.0,\
 0.0,1E+100,0.0,0,512)
DeclareVariable("chi.mecChi.chi.COPCar", "Carnot efficiency", 531, 0.0, 0.0,\
1E+100,0.0,0,512)
DeclareVariable("chi.mecChi.chi.TConAct", "Condenser temperature used to compute efficiency, taking into account pinch temperature between fluid and refrigerant [K|degC]",\
 532, 305.15, 0.0,1E+100,300.0,0,512)
DeclareVariable("chi.mecChi.chi.TEvaAct", "Evaporator temperature used to compute efficiency, taking into account pinch temperature between fluid and refrigerant [K|degC]",\
 533, 276.15, 0.0,1E+100,300.0,0,512)
DeclareVariable("chi.mecChi.chi.COP_is_for_cooling", "Set to true if the specified COP is for cooling [:#(type=Boolean)]",\
 158, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.etaCarnot_nominal_internal", "Carnot effectiveness (=COP/COP_Carnot) used to compute COP [1]",\
 159, 0.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.evaluate_etaPL", "Flag, true if etaPL should be computed as it depends on yPL [:#(type=Boolean)]",\
 160, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.TUseAct_nominal", "Nominal evaporator temperature for chiller or condenser temperature for heat pump, taking into account pinch temperature between fluid and refrigerant [K|degC]",\
 161, 276.15, 0.0,1E+100,300.0,0,2561)
DeclareAlias2("chi.mecChi.chi.TUseAct", "Temperature of useful heat (evaporator for chiller, condenser for heat pump), taking into account pinch temperature between fluid and refrigerant [K|degC]",\
 "chi.mecChi.chi.TEvaAct", 1, 5, 533, 1024)
DeclareVariable("chi.mecChi.chi.cp1_default", "Specific heat capacity of medium 1 at default medium state [J/(kg.K)]",\
 162, 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.cp2_default", "Specific heat capacity of medium 2 at default medium state [J/(kg.K)]",\
 163, 4184, 0.0,0.0,0.0,0,2561)
DeclareAlias2("chi.mecChi.chi.staA1.p", "Absolute pressure of medium [Pa|bar]", \
"sou1.ports[1].p", 1, 5, 5, 1024)
DeclareVariable("chi.mecChi.chi.staA1.T", "Temperature of medium [K|degC]", 534,\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("chi.mecChi.chi.staB1.p", "Absolute pressure of medium [Pa|bar]", \
"sin1.p", 1, 7, 24, 1024)
DeclareVariable("chi.mecChi.chi.staB1.T", "Temperature of medium [K|degC]", 535,\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("chi.mecChi.chi.staA2.p", "Absolute pressure of medium [Pa|bar]", \
"sou2.ports[1].p", 1, 5, 16, 1024)
DeclareVariable("chi.mecChi.chi.staA2.T", "Temperature of medium [K|degC]", 536,\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("chi.mecChi.chi.staB2.p", "Absolute pressure of medium [Pa|bar]", \
"sin2.p", 1, 7, 21, 1024)
DeclareVariable("chi.mecChi.chi.staB2.T", "Temperature of medium [K|degC]", 537,\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("chi.mecChi.chi.con.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 164, true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("chi.mecChi.chi.con.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 1156)
DeclareAlias2("chi.mecChi.chi.con.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou1.ports[1].p", 1, 5, 5, 1028)
DeclareAlias2("chi.mecChi.chi.con.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_a1.h_outflow", 1, 5, 519, 1028)
DeclareAlias2("chi.mecChi.chi.con.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", -1, 5, 12, 1156)
DeclareAlias2("chi.mecChi.chi.con.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 24, 1028)
DeclareAlias2("chi.mecChi.chi.con.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_b1.h_outflow", 1, 5, 520, 1028)
DeclareVariable("chi.mecChi.chi.con.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 165, 1.3769614953517504, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 166, 0.00013769614953517505, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 167, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("chi.mecChi.chi.con.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 1024)
DeclareVariable("chi.mecChi.chi.con.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 168, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 169, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 170, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.computeFlowResistance", "=true, compute flow resistance. Set to false to assume no friction [:#(type=Boolean)]",\
 171, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 172, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.dp_nominal", "Pressure difference [Pa|Pa]", 173,\
 1000, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.linearizeFlowResistance", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 174, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.deltaM", "Fraction of nominal flow rate where flow transitions to laminar",\
 175, 0.1, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 176, true, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.mecChi.chi.con.tau", "Time constant at nominal flow (if energyDynamics <> SteadyState) [s]",\
 177, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 178, 4, 1.0,4.0,0.0,0,2565)
DeclareParameter("chi.mecChi.chi.con.p_start", "Start value of pressure [Pa|bar]",\
 54, 300000, 0.0,100000000.0,100000.0,0,2608)
DeclareVariable("chi.mecChi.chi.con.T_start", "Start value of temperature [K|degC]",\
 179, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareParameter("chi.mecChi.chi.con.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 55, 1, 0.0,1.0,0.1,0,2608)
DeclareVariable("chi.mecChi.chi.con.vol.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 180, 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("chi.mecChi.chi.con.vol.massDynamics", "Type of mass balance: dynamic (3 initialization options) or steady state, must be steady state if energyDynamics is steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 181, 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("chi.mecChi.chi.con.vol.substanceDynamics", "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 182, 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("chi.mecChi.chi.con.vol.traceDynamics", "Type of trace substance balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 183, 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("chi.mecChi.chi.con.vol.p_start", "Start value of pressure [Pa|bar]",\
 184, 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.T_start", "Start value of temperature [K|degC]",\
 185, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 186, 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.mSenFac", "Factor for scaling the sensible thermal mass of the volume",\
 187, 1, 1.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.wrongEnergyMassBalanceConfiguration", \
"True if configuration of energy and mass balance is wrong. [:#(type=Boolean)]",\
 188, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.vol.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 189, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.mecChi.chi.con.vol.prescribedHeatFlowRate", \
"Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false [:#(type=Boolean)]",\
 190, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.vol.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 191, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 192, 1.3769614953517504, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.nPorts", "Number of ports [:#(type=Integer)]",\
 193, 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("chi.mecChi.chi.con.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 194, 0.00013769614953517505, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports. [:#(type=Boolean)]",\
 195, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.vol.V", "Volume [m3]", 196, 0.0, 0.0,0.0,0.0,\
0,2561)
DeclareAlias2("chi.mecChi.chi.con.vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 1156)
DeclareAlias2("chi.mecChi.chi.con.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 24, 1028)
DeclareAlias2("chi.mecChi.chi.con.vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_a1.h_outflow", 1, 5, 519, 1028)
DeclareAlias2("chi.mecChi.chi.con.vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", -1, 5, 12, 1156)
DeclareAlias2("chi.mecChi.chi.con.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 24, 1028)
DeclareAlias2("chi.mecChi.chi.con.vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_b1.h_outflow", 1, 5, 520, 1028)
DeclareVariable("chi.mecChi.chi.con.vol.T", "Temperature of the fluid [K|degC]",\
 538, 300.0, 1.0,10000.0,300.0,0,2560)
DeclareVariable("chi.mecChi.chi.con.vol.U", "Internal energy of the component [J]",\
 197, 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("chi.mecChi.chi.con.vol.p", "Pressure of the fluid [Pa|bar]", \
"sin1.p", 1, 7, 24, 1024)
DeclareVariable("chi.mecChi.chi.con.vol.m", "Mass of the component [kg]", 198, 0,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 199, 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 200, 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.state_default.T", "Temperature of medium [K|degC]",\
 201, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 202, 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.state_start.p", "Absolute pressure of medium [Pa|bar]",\
 203, 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.state_start.T", "Temperature of medium [K|degC]",\
 204, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.useSteadyStateTwoPort", "Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 205, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 539, 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("chi.mecChi.chi.con.vol.preTem.port.T", "Port temperature [K|degC]",\
 "chi.mecChi.chi.con.vol.T", 1, 5, 538, 1028)
DeclareAlias2("chi.mecChi.chi.con.vol.preTem.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "chi.mecChi.QCon_flow", 1, 5, 551, 1156)
DeclareAlias2("chi.mecChi.chi.con.vol.preTem.T", "", "chi.mecChi.chi.con.vol.T", 1,\
 5, 538, 1024)
DeclareAlias2("chi.mecChi.chi.con.vol.portT.y", "Value of Real output", \
"chi.mecChi.chi.con.vol.T", 1, 5, 538, 1024)
DeclareAlias2("chi.mecChi.chi.con.vol.heaFloSen.Q_flow", "Heat flow from port_a to port_b as output signal [W]",\
 "chi.mecChi.QCon_flow", 1, 5, 551, 1024)
DeclareAlias2("chi.mecChi.chi.con.vol.heaFloSen.port_a.T", "Port temperature [K|degC]",\
 "chi.mecChi.chi.con.vol.T", 1, 5, 538, 1028)
DeclareAlias2("chi.mecChi.chi.con.vol.heaFloSen.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "chi.mecChi.QCon_flow", 1, 5, 551, 1156)
DeclareAlias2("chi.mecChi.chi.con.vol.heaFloSen.port_b.T", "Port temperature [K|degC]",\
 "chi.mecChi.chi.con.vol.T", 1, 5, 538, 1028)
DeclareAlias2("chi.mecChi.chi.con.vol.heaFloSen.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "chi.mecChi.QCon_flow", -1, 5, 551, 1156)
DeclareVariable("chi.mecChi.chi.con.vol.use_C_flow", "Set to true to enable input connector for trace substance [:#(type=Boolean)]",\
 206, false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("chi.mecChi.chi.con.vol.heatPort.T", "Port temperature [K|degC]", \
"chi.mecChi.chi.con.vol.T", 1, 5, 538, 1028)
DeclareAlias2("chi.mecChi.chi.con.vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "chi.mecChi.QCon_flow", 1, 5, 551, 1156)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.allowFlowReversal", \
"= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 207, true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("chi.mecChi.chi.con.vol.steBal.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 1156)
DeclareAlias2("chi.mecChi.chi.con.vol.steBal.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 24, 1028)
DeclareAlias2("chi.mecChi.chi.con.vol.steBal.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_a1.h_outflow", 1, 5, 519, 1028)
DeclareAlias2("chi.mecChi.chi.con.vol.steBal.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", -1, 5, 12, 1156)
DeclareAlias2("chi.mecChi.chi.con.vol.steBal.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 24, 1028)
DeclareAlias2("chi.mecChi.chi.con.vol.steBal.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_b1.h_outflow", 1, 5, 520, 1028)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 208, 1.3769614953517504, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 209, 0.00013769614953517505, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 210, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("chi.mecChi.chi.con.vol.steBal.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 1024)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 211, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 212, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 213, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.simplify_mWat_flow", \
"Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 214, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.prescribedHeatFlowRate", \
"Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature [:#(type=Boolean)]",\
 215, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.use_mWat_flow", "Set to true to enable input connector for moisture mass flow rate [:#(type=Boolean)]",\
 216, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.use_C_flow", "Set to true to enable input connector for trace substance [:#(type=Boolean)]",\
 217, false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("chi.mecChi.chi.con.vol.steBal.Q_flow", "Sensible plus latent heat flow rate transferred into the medium [W]",\
 "chi.mecChi.QCon_flow", 1, 5, 551, 1024)
DeclareAlias2("chi.mecChi.chi.con.vol.steBal.hOut", "Leaving specific enthalpy of the component [J/kg]",\
 "chi.mecChi.chi.con.vol.hOut_internal", 1, 5, 539, 1024)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.use_m_flowInv", "Flag, true if m_flowInv is used in the model [:#(type=Boolean)]",\
 218, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.m_flowInv", "Regularization of 1/m_flow of port_a [s/kg]",\
 219, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.deltaReg", "Smoothing region for inverseXRegularized",\
 220, 1.3769614953517503E-07, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.deltaInvReg", "Inverse value of delta for inverseXRegularized",\
 221, 7262367.200359121, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.aReg", "Polynomial coefficient for inverseXRegularized",\
 222, -108935508.00538681, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.bReg", "Polynomial coefficient for inverseXRegularized",\
 223, 6276295304989385.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.cReg", "Polynomial coefficient for inverseXRegularized",\
 224, -1.382744099138063E+23, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.dReg", "Polynomial coefficient for inverseXRegularized",\
 225, 1.485436437497393E+30, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.eReg", "Polynomial coefficient for inverseXRegularized",\
 226, -7.67670083805573E+36, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.fReg", "Polynomial coefficient for inverseXRegularized",\
 227, 1.5258173996893662E+43, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.state_default.p", \
"Absolute pressure of medium [Pa|bar]", 228, 300000.0, 0.0,100000000.0,100000.0,\
0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.state_default.T", \
"Temperature of medium [K|degC]", 229, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.cp_default", "Specific heat capacity, used to verify energy conservation [J/(kg.K)]",\
 230, 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.dTMax", "Maximum temperature difference across the StaticTwoPortConservationEquation [K,]",\
 231, 200, 1.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.vol.steBal.mWat_flow_internal", \
"Needed to connect to conditional connector [kg/s]", 232, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.preDro.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 233, true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("chi.mecChi.chi.con.preDro.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 1156)
DeclareAlias2("chi.mecChi.chi.con.preDro.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou1.ports[1].p", 1, 5, 5, 1028)
DeclareAlias2("chi.mecChi.chi.con.preDro.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_a1.h_outflow", 1, 5, 519, 1028)
DeclareAlias2("chi.mecChi.chi.con.preDro.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou1.m_flow", -1, 5, 12, 1156)
DeclareAlias2("chi.mecChi.chi.con.preDro.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin1.p", 1, 7, 24, 1028)
DeclareAlias2("chi.mecChi.chi.con.preDro.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sou1.ports[1].h_outflow", 1, 5, 505, 1028)
DeclareVariable("chi.mecChi.chi.con.preDro.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 234, 1.3769614953517504, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.preDro.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 235, 0.00013769614953517505, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.preDro.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 236, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("chi.mecChi.chi.con.preDro.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "sou1.m_flow", 1, 5, 12, 1024)
DeclareVariable("chi.mecChi.chi.con.preDro.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 237, 0, 0.0,0.0,1000.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.preDro._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 238, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.preDro._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 239, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.preDro.homotopyInitialization", \
"= true, use homotopy method [:#(type=Boolean)]", 240, true, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.mecChi.chi.con.preDro.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 241, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.preDro.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 242, 1000, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.preDro.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 243, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.preDro.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 244, 0.13769614953517503, 0.0,1E+100,0.0,0,2561)
DeclareParameter("chi.mecChi.chi.con.preDro.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 56, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("chi.mecChi.chi.con.preDro.sta_default.T", "Temperature of medium [K|degC]",\
 57, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("chi.mecChi.chi.con.preDro.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 245, 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.preDro.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 246, 1.3769614953517504, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.preDro.dp_nominal_pos", "Absolute value of nominal pressure difference [Pa|Pa]",\
 247, 1000, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.preDro.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs",\
 248, 0.1, 1E-06,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.preDro.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 249, 0.04354334575662886, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.preDro.computeFlowResistance", \
"Flag to enable/disable computation of flow resistance [:#(type=Boolean)]", 250,\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.con.preDro.coeff", "Precomputed coefficient to avoid division by parameter",\
 251, 0, 0.0,0.0,0.0,0,2561)
DeclareParameter("chi.mecChi.chi.con.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 58, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("chi.mecChi.chi.con.sta_default.T", "Temperature of medium [K|degC]",\
 59, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("chi.mecChi.chi.con.rho_default", "Density, used to compute fluid volume [kg/m3|g/cm3]",\
 252, 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.sta_start.p", "Absolute pressure of medium [Pa|bar]",\
 253, 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.sta_start.T", "Temperature of medium [K|degC]",\
 254, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.h_outflow_start", "Start value for outflowing enthalpy [J/kg]",\
 255, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.Q_flow_nominal", "Heat flow rate at u=1, positive for heating [W]",\
 256, 57612.06896551724, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.con.u", "Control input [1]", 540, 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareAlias2("chi.mecChi.chi.con.Q_flow", "Heat added to the fluid [W]", \
"chi.mecChi.QCon_flow", 1, 5, 551, 1024)
DeclareParameter("chi.mecChi.chi.con.preHea.T_ref", "Reference temperature [K|degC]",\
 60, 293.15, 0.0,1E+100,300.0,0,2608)
DeclareVariable("chi.mecChi.chi.con.preHea.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 257, 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("chi.mecChi.chi.con.preHea.Q_flow", "[W]", "chi.mecChi.QCon_flow", 1,\
 5, 551, 1024)
DeclareAlias2("chi.mecChi.chi.con.preHea.port.T", "Port temperature [K|degC]", \
"chi.mecChi.chi.con.vol.T", 1, 5, 538, 1028)
DeclareAlias2("chi.mecChi.chi.con.preHea.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "chi.mecChi.QCon_flow", -1, 5, 551, 1156)
DeclareVariable("chi.mecChi.chi.con.gai.k", "Gain value multiplied with input signal [W]",\
 258, 57612.06896551724, 0.0,0.0,0.0,0,2561)
DeclareAlias2("chi.mecChi.chi.con.gai.u", "Input signal connector", \
"chi.mecChi.chi.con.u", 1, 5, 540, 1024)
DeclareAlias2("chi.mecChi.chi.con.gai.y", "Output signal connector [W]", \
"chi.mecChi.QCon_flow", 1, 5, 551, 1024)
DeclareVariable("chi.mecChi.chi.eva.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 259, true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("chi.mecChi.chi.eva.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 1156)
DeclareAlias2("chi.mecChi.chi.eva.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou2.ports[1].p", 1, 5, 16, 1028)
DeclareAlias2("chi.mecChi.chi.eva.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_a2.h_outflow", 1, 5, 521, 1028)
DeclareAlias2("chi.mecChi.chi.eva.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", -1, 5, 23, 1156)
DeclareAlias2("chi.mecChi.chi.eva.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 21, 1028)
DeclareAlias2("chi.mecChi.chi.eva.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "senTem.port_b.h_outflow", 1, 5, 516, 1028)
DeclareVariable("chi.mecChi.chi.eva.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 260, 1.137955759214083, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 261, 0.0001137955759214083, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 262, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("chi.mecChi.chi.eva.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 1024)
DeclareVariable("chi.mecChi.chi.eva.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 263, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 264, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 265, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.computeFlowResistance", "=true, compute flow resistance. Set to false to assume no friction [:#(type=Boolean)]",\
 266, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 267, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.dp_nominal", "Pressure difference [Pa|Pa]", 268,\
 1000, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.linearizeFlowResistance", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 269, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.deltaM", "Fraction of nominal flow rate where flow transitions to laminar",\
 270, 0.1, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 271, true, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.mecChi.chi.eva.tau", "Time constant at nominal flow (if energyDynamics <> SteadyState) [s]",\
 272, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 273, 4, 1.0,4.0,0.0,0,2565)
DeclareParameter("chi.mecChi.chi.eva.p_start", "Start value of pressure [Pa|bar]",\
 61, 300000, 0.0,100000000.0,100000.0,0,2608)
DeclareVariable("chi.mecChi.chi.eva.T_start", "Start value of temperature [K|degC]",\
 274, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareParameter("chi.mecChi.chi.eva.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 62, 1, 0.0,1.0,0.1,0,2608)
DeclareVariable("chi.mecChi.chi.eva.vol.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 275, 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("chi.mecChi.chi.eva.vol.massDynamics", "Type of mass balance: dynamic (3 initialization options) or steady state, must be steady state if energyDynamics is steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 276, 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("chi.mecChi.chi.eva.vol.substanceDynamics", "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 277, 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("chi.mecChi.chi.eva.vol.traceDynamics", "Type of trace substance balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 278, 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("chi.mecChi.chi.eva.vol.p_start", "Start value of pressure [Pa|bar]",\
 279, 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.T_start", "Start value of temperature [K|degC]",\
 280, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 281, 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.mSenFac", "Factor for scaling the sensible thermal mass of the volume",\
 282, 1, 1.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.wrongEnergyMassBalanceConfiguration", \
"True if configuration of energy and mass balance is wrong. [:#(type=Boolean)]",\
 283, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.vol.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 284, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.mecChi.chi.eva.vol.prescribedHeatFlowRate", \
"Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false [:#(type=Boolean)]",\
 285, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.vol.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 286, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 287, 1.137955759214083, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.nPorts", "Number of ports [:#(type=Integer)]",\
 288, 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("chi.mecChi.chi.eva.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 289, 0.0001137955759214083, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports. [:#(type=Boolean)]",\
 290, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.vol.V", "Volume [m3]", 291, 0.0, 0.0,0.0,0.0,\
0,2561)
DeclareAlias2("chi.mecChi.chi.eva.vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 1156)
DeclareAlias2("chi.mecChi.chi.eva.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 21, 1028)
DeclareAlias2("chi.mecChi.chi.eva.vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_a2.h_outflow", 1, 5, 521, 1028)
DeclareAlias2("chi.mecChi.chi.eva.vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", -1, 5, 23, 1156)
DeclareAlias2("chi.mecChi.chi.eva.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 21, 1028)
DeclareAlias2("chi.mecChi.chi.eva.vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "senTem.port_b.h_outflow", 1, 5, 516, 1028)
DeclareVariable("chi.mecChi.chi.eva.vol.T", "Temperature of the fluid [K|degC]",\
 541, 300.0, 1.0,10000.0,300.0,0,2560)
DeclareVariable("chi.mecChi.chi.eva.vol.U", "Internal energy of the component [J]",\
 292, 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("chi.mecChi.chi.eva.vol.p", "Pressure of the fluid [Pa|bar]", \
"sin2.p", 1, 7, 21, 1024)
DeclareVariable("chi.mecChi.chi.eva.vol.m", "Mass of the component [kg]", 293, 0,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 294, 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 295, 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.state_default.T", "Temperature of medium [K|degC]",\
 296, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 297, 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.state_start.p", "Absolute pressure of medium [Pa|bar]",\
 298, 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.state_start.T", "Temperature of medium [K|degC]",\
 299, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.useSteadyStateTwoPort", "Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 300, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 542, 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("chi.mecChi.chi.eva.vol.preTem.port.T", "Port temperature [K|degC]",\
 "chi.mecChi.chi.eva.vol.T", 1, 5, 541, 1028)
DeclareAlias2("chi.mecChi.chi.eva.vol.preTem.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "chi.mecChi.QEva_flow", 1, 5, 553, 1156)
DeclareAlias2("chi.mecChi.chi.eva.vol.preTem.T", "", "chi.mecChi.chi.eva.vol.T", 1,\
 5, 541, 1024)
DeclareAlias2("chi.mecChi.chi.eva.vol.portT.y", "Value of Real output", \
"chi.mecChi.chi.eva.vol.T", 1, 5, 541, 1024)
DeclareAlias2("chi.mecChi.chi.eva.vol.heaFloSen.Q_flow", "Heat flow from port_a to port_b as output signal [W]",\
 "chi.mecChi.QEva_flow", 1, 5, 553, 1024)
DeclareAlias2("chi.mecChi.chi.eva.vol.heaFloSen.port_a.T", "Port temperature [K|degC]",\
 "chi.mecChi.chi.eva.vol.T", 1, 5, 541, 1028)
DeclareAlias2("chi.mecChi.chi.eva.vol.heaFloSen.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "chi.mecChi.QEva_flow", 1, 5, 553, 1156)
DeclareAlias2("chi.mecChi.chi.eva.vol.heaFloSen.port_b.T", "Port temperature [K|degC]",\
 "chi.mecChi.chi.eva.vol.T", 1, 5, 541, 1028)
DeclareAlias2("chi.mecChi.chi.eva.vol.heaFloSen.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "chi.mecChi.QEva_flow", -1, 5, 553, 1156)
DeclareVariable("chi.mecChi.chi.eva.vol.use_C_flow", "Set to true to enable input connector for trace substance [:#(type=Boolean)]",\
 301, false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("chi.mecChi.chi.eva.vol.heatPort.T", "Port temperature [K|degC]", \
"chi.mecChi.chi.eva.vol.T", 1, 5, 541, 1028)
DeclareAlias2("chi.mecChi.chi.eva.vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "chi.mecChi.QEva_flow", 1, 5, 553, 1156)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.allowFlowReversal", \
"= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 302, true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("chi.mecChi.chi.eva.vol.steBal.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 1156)
DeclareAlias2("chi.mecChi.chi.eva.vol.steBal.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 21, 1028)
DeclareAlias2("chi.mecChi.chi.eva.vol.steBal.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_a2.h_outflow", 1, 5, 521, 1028)
DeclareAlias2("chi.mecChi.chi.eva.vol.steBal.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", -1, 5, 23, 1156)
DeclareAlias2("chi.mecChi.chi.eva.vol.steBal.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 21, 1028)
DeclareAlias2("chi.mecChi.chi.eva.vol.steBal.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "senTem.port_b.h_outflow", 1, 5, 516, 1028)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 303, 1.137955759214083, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 304, 0.0001137955759214083, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 305, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("chi.mecChi.chi.eva.vol.steBal.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 1024)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 306, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 307, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 308, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.simplify_mWat_flow", \
"Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 309, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.prescribedHeatFlowRate", \
"Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature [:#(type=Boolean)]",\
 310, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.use_mWat_flow", "Set to true to enable input connector for moisture mass flow rate [:#(type=Boolean)]",\
 311, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.use_C_flow", "Set to true to enable input connector for trace substance [:#(type=Boolean)]",\
 312, false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("chi.mecChi.chi.eva.vol.steBal.Q_flow", "Sensible plus latent heat flow rate transferred into the medium [W]",\
 "chi.mecChi.QEva_flow", 1, 5, 553, 1024)
DeclareAlias2("chi.mecChi.chi.eva.vol.steBal.hOut", "Leaving specific enthalpy of the component [J/kg]",\
 "chi.mecChi.chi.eva.vol.hOut_internal", 1, 5, 542, 1024)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.use_m_flowInv", "Flag, true if m_flowInv is used in the model [:#(type=Boolean)]",\
 313, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.m_flowInv", "Regularization of 1/m_flow of port_a [s/kg]",\
 314, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.deltaReg", "Smoothing region for inverseXRegularized",\
 315, 1.137955759214083E-07, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.deltaInvReg", "Inverse value of delta for inverseXRegularized",\
 316, 8787687.850805722, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.aReg", "Polynomial coefficient for inverseXRegularized",\
 317, -131815317.76208583, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.bReg", "Polynomial coefficient for inverseXRegularized",\
 318, 9189591473820622.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.cReg", "Polynomial coefficient for inverseXRegularized",\
 319, -2.4498024661141544E+23, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.dReg", "Polynomial coefficient for inverseXRegularized",\
 320, 3.184488937035004E+30, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.eReg", "Polynomial coefficient for inverseXRegularized",\
 321, -1.991391760738378E+37, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.fReg", "Polynomial coefficient for inverseXRegularized",\
 322, 4.789399565609649E+43, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.state_default.p", \
"Absolute pressure of medium [Pa|bar]", 323, 300000.0, 0.0,100000000.0,100000.0,\
0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.state_default.T", \
"Temperature of medium [K|degC]", 324, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.cp_default", "Specific heat capacity, used to verify energy conservation [J/(kg.K)]",\
 325, 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.dTMax", "Maximum temperature difference across the StaticTwoPortConservationEquation [K,]",\
 326, 200, 1.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.vol.steBal.mWat_flow_internal", \
"Needed to connect to conditional connector [kg/s]", 327, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.preDro.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 328, true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("chi.mecChi.chi.eva.preDro.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 1156)
DeclareAlias2("chi.mecChi.chi.eva.preDro.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sou2.ports[1].p", 1, 5, 16, 1028)
DeclareAlias2("chi.mecChi.chi.eva.preDro.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "chi.port_a2.h_outflow", 1, 5, 521, 1028)
DeclareAlias2("chi.mecChi.chi.eva.preDro.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sou2.m_flow", -1, 5, 23, 1156)
DeclareAlias2("chi.mecChi.chi.eva.preDro.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sin2.p", 1, 7, 21, 1028)
DeclareAlias2("chi.mecChi.chi.eva.preDro.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sou2.ports[1].h_outflow", 1, 5, 507, 1028)
DeclareVariable("chi.mecChi.chi.eva.preDro.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 329, 1.137955759214083, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.preDro.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 330, 0.0001137955759214083, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.preDro.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 331, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("chi.mecChi.chi.eva.preDro.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "sou2.m_flow", 1, 5, 23, 1024)
DeclareVariable("chi.mecChi.chi.eva.preDro.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 332, 0, 0.0,0.0,1000.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.preDro._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 333, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.preDro._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 334, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.preDro.homotopyInitialization", \
"= true, use homotopy method [:#(type=Boolean)]", 335, true, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.mecChi.chi.eva.preDro.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 336, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.preDro.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 337, 1000, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.preDro.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 338, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.preDro.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 339, 0.1137955759214083, 0.0,1E+100,0.0,0,2561)
DeclareParameter("chi.mecChi.chi.eva.preDro.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 63, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("chi.mecChi.chi.eva.preDro.sta_default.T", "Temperature of medium [K|degC]",\
 64, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("chi.mecChi.chi.eva.preDro.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 340, 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.preDro.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 341, 1.137955759214083, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.preDro.dp_nominal_pos", "Absolute value of nominal pressure difference [Pa|Pa]",\
 342, 1000, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.preDro.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs",\
 343, 0.1, 1E-06,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.preDro.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 344, 0.03598532075622642, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.preDro.computeFlowResistance", \
"Flag to enable/disable computation of flow resistance [:#(type=Boolean)]", 345,\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.chi.eva.preDro.coeff", "Precomputed coefficient to avoid division by parameter",\
 346, 0, 0.0,0.0,0.0,0,2561)
DeclareParameter("chi.mecChi.chi.eva.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 65, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("chi.mecChi.chi.eva.sta_default.T", "Temperature of medium [K|degC]",\
 66, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("chi.mecChi.chi.eva.rho_default", "Density, used to compute fluid volume [kg/m3|g/cm3]",\
 347, 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.sta_start.p", "Absolute pressure of medium [Pa|bar]",\
 348, 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.sta_start.T", "Temperature of medium [K|degC]",\
 349, 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.h_outflow_start", "Start value for outflowing enthalpy [J/kg]",\
 350, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.Q_flow_nominal", "Heat flow rate at u=1, positive for heating [W]",\
 351, -47612.06896551724, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.chi.eva.u", "Control input [1]", 543, 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareAlias2("chi.mecChi.chi.eva.Q_flow", "Heat added to the fluid [W]", \
"chi.mecChi.QEva_flow", 1, 5, 553, 1024)
DeclareParameter("chi.mecChi.chi.eva.preHea.T_ref", "Reference temperature [K|degC]",\
 67, 293.15, 0.0,1E+100,300.0,0,2608)
DeclareVariable("chi.mecChi.chi.eva.preHea.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 352, 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("chi.mecChi.chi.eva.preHea.Q_flow", "[W]", "chi.mecChi.QEva_flow", 1,\
 5, 553, 1024)
DeclareAlias2("chi.mecChi.chi.eva.preHea.port.T", "Port temperature [K|degC]", \
"chi.mecChi.chi.eva.vol.T", 1, 5, 541, 1028)
DeclareAlias2("chi.mecChi.chi.eva.preHea.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "chi.mecChi.QEva_flow", -1, 5, 553, 1156)
DeclareVariable("chi.mecChi.chi.eva.gai.k", "Gain value multiplied with input signal [W]",\
 353, -47612.06896551724, 0.0,0.0,0.0,0,2561)
DeclareAlias2("chi.mecChi.chi.eva.gai.u", "Input signal connector", \
"chi.mecChi.chi.eva.u", 1, 5, 543, 1024)
DeclareAlias2("chi.mecChi.chi.eva.gai.y", "Output signal connector [W]", \
"chi.mecChi.QEva_flow", 1, 5, 553, 1024)
DeclareVariable("chi.mecChi.chi.P_nominal", "Nominal compressor power (at y=1) [W]",\
 354, 10000.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.chi.y", "Part load ratio of compressor [1]", 544, \
0.0, 0.0,1.0,0.0,0,512)
DeclareVariable("chi.mecChi.chi.QCon_flow_internal", "Condenser heat input [W]",\
 545, 57612.06896551724, 0.0,0.0,0.0,0,2560)
DeclareVariable("chi.mecChi.chi.QEva_flow_internal", "Evaporator heat input [W]",\
 546, -47612.06896551724, 0.0,0.0,0.0,0,2624)
DeclareAlias2("chi.mecChi.chi.yEva_flow_in.y", "Value of Real output", \
"chi.mecChi.chi.eva.u", 1, 5, 543, 1024)
DeclareAlias2("chi.mecChi.chi.yCon_flow_in.y", "Value of Real output", \
"chi.mecChi.chi.con.u", 1, 5, 540, 1024)
DeclareVariable("chi.mecChi.chi.PEle.k", "Gain value multiplied with input signal [1]",\
 355, 10000.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("chi.mecChi.chi.PEle.u", "Input signal connector", \
"chi.mecChi.chi.y", 1, 5, 544, 1024)
DeclareAlias2("chi.mecChi.chi.PEle.y", "Output signal connector", "chi.mecChi.P", 1,\
 5, 552, 1024)
DeclareAlias2("chi.mecChi.shaft.phi", "Absolute rotation angle of flange [rad|deg]",\
 "chi.mecChi.ine.phi", 1, 5, 548, 4)
DeclareVariable("chi.mecChi.shaft.tau", "Cut torque in the flange [N.m]", 547, \
0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("chi.mecChi.ine.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "chi.mecChi.ine.phi", 1, 5, 548, 4)
DeclareAlias2("chi.mecChi.ine.flange_a.tau", "Cut torque in the flange [N.m]", \
"chi.mecChi.tauChi", -1, 5, 526, 132)
DeclareAlias2("chi.mecChi.ine.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "chi.mecChi.ine.phi", 1, 5, 548, 4)
DeclareAlias2("chi.mecChi.ine.flange_b.tau", "Cut torque in the flange [N.m]", \
"chi.mecChi.shaft.tau", 1, 5, 547, 132)
DeclareVariable("chi.mecChi.ine.J", "Moment of inertia [kg.m2]", 356, 1, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("chi.mecChi.ine.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 357, 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("chi.mecChi.ine.phi", "Absolute rotation angle of component [rad|deg]",\
 548, 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("chi.mecChi.ine.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "chi.mecChi.ine.w", 1, 1, 1, 0)
DeclareState("chi.mecChi.ine.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 1, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("chi.mecChi.ine.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("chi.mecChi.ine.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "chi.mecChi.ine.der(w)", 1, 6, 1, 0)
DeclareVariable("chi.mecChi.tor.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 358, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("chi.mecChi.tor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "chi.mecChi.ine.phi", 1, 5, 548, 4)
DeclareAlias2("chi.mecChi.tor.flange.tau", "Cut torque in the flange [N.m]", \
"chi.mecChi.tauChi", 1, 5, 526, 132)
DeclareVariable("chi.mecChi.tor.phi_support", "Absolute angle of support flange [rad|deg]",\
 359, 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("chi.mecChi.tor.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "chi.mecChi.tauChi", -1, 5, 526, 0)
DeclareAlias2("chi.mecChi.tauSor.y", "Value of Real output", "chi.mecChi.tauChi", -1,\
 5, 526, 0)
DeclareAlias2("chi.mecChi.spe.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "chi.mecChi.ine.phi", 1, 5, 548, 4)
DeclareAlias2("chi.mecChi.spe.flange.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "chi.mecChi.ine.w", 1, 1, 1, 4)
DeclareVariable("chi.mecChi.spe.flange.tau", "Cut torque in the flange [N.m]", 360,\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("chi.mecChi.spe.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "chi.mecChi.ine.w", 1, 1, 1, 0)
DeclareAlias2("chi.mecChi.to_rpm.u", "Connector of Real input signal to be converted [rad/s]",\
 "chi.mecChi.ine.w", 1, 1, 1, 0)
DeclareVariable("chi.mecChi.to_rpm.y", "Connector of Real output signal containing input signal u in another unit [rev/min]",\
 549, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("chi.mecChi.multiProduct.significantDigits", "Number of significant digits to be shown in dynamic diagram layer for y [:#(type=Integer)]",\
 68, 3, 1.0,1E+100,0.0,0,564)
DeclareVariable("chi.mecChi.multiProduct.nu", "Number of input connections [:#(type=Integer)]",\
 361, 3, 0.0,1E+100,0.0,0,1541)
DeclareVariable("chi.mecChi.multiProduct.u[1]", "", 550, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("chi.mecChi.multiProduct.u[2]", "", "chi.mecChi.multiProduct.u[1]", 1,\
 5, 550, 0)
DeclareAlias2("chi.mecChi.multiProduct.u[3]", "", "chi.mecChi.multiProduct.u[1]", 1,\
 5, 550, 0)
DeclareAlias2("chi.mecChi.multiProduct.y", "", "chi.mecChi.chi.y", 1, 5, 544, 0)
DeclareVariable("chi.mecChi.gaiSpe.k", "Gain value multiplied with input signal [1]",\
 362, 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.mecChi.gaiSpe.u", "Input signal connector", "chi.mecChi.to_rpm.y", 1,\
 5, 549, 0)
DeclareAlias2("chi.mecChi.gaiSpe.y", "Output signal connector", "chi.mecChi.multiProduct.u[1]", 1,\
 5, 550, 0)
DeclareVariable("chi.mecChi.QCon_flow", "Actual heating heat flow rate added to fluid 1 [W]",\
 551, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.mecChi.P", "Electric power consumed [W]", 552, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("chi.mecChi.QEva_flow", "Actual cooling heat flow rate removed from fluid 2 [W]",\
 553, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.mecChi.COP_is_for_cooling", "Set to true if the specified COP is for cooling [:#(type=Boolean)]",\
 363, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.mecChi.TUseAct_nominal", "Nominal evaporator temperature for chiller or condenser temperature for     heat pump, taking into account pinch temperature between fluid and refrigerant [K|degC]",\
 364, 276.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("chi.mecChi.cp1_default", "Specific heat capacity of medium 1 at default medium state [J/(kg.K)]",\
 365, 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.mecChi.cp2_default", "Specific heat capacity of medium 2 at default medium state [J/(kg.K)]",\
 366, 4184, 0.0,0.0,0.0,0,2561)
DeclareAlias2("chi.loaTor.y", "Value of Real output", "chi.mecChi.shaft.tau", 1,\
 5, 547, 0)
DeclareAlias2("chi.simMot.terminal.v[1]", "Voltage vector [V]", "Sou.terminal.v[1]", 1,\
 5, 25, 4)
DeclareAlias2("chi.simMot.terminal.v[2]", "Voltage vector [V]", "Sou.terminal.v[2]", 1,\
 5, 26, 4)
DeclareAlias2("chi.simMot.terminal.i[1]", "Current vector [A]", "Sou.terminal.i[1]", -1,\
 5, 509, 132)
DeclareAlias2("chi.simMot.terminal.i[2]", "Current vector [A]", "Sou.terminal.i[2]", -1,\
 5, 510, 132)
DeclareAlias2("chi.simMot.terminal.theta[1]", "Optional vector of phase angles [rad|deg]",\
 "chi.simMot.theta_s", 1, 5, 556, 4)
DeclareParameter("chi.simMot.per.P", "Number of Poles [:#(type=Integer)]", 69, 4,\
 0.0,0.0,0.0,0,564)
DeclareParameter("chi.simMot.per.J", "Moment of Inertia [kg/m\302\262] []", 70, \
0.17, 0.0,0.0,0.0,0,560)
DeclareParameter("chi.simMot.per.Lr", "Rotor Inductance [H] []", 71, 0.1458, \
0.0,0.0,0.0,0,560)
DeclareParameter("chi.simMot.per.Ls", "Stator Inductance [H] []", 72, 0.1457, \
0.0,0.0,0.0,0,560)
DeclareParameter("chi.simMot.per.Lm", "Mutual Inductance [H] []", 73, 0.1406, \
0.0,0.0,0.0,0,560)
DeclareParameter("chi.simMot.per.Rs", "Stator Resistance [ohm] []", 74, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("chi.simMot.per.Rr", "Rotor Resistance [ohm] []", 75, 1.145, \
0.0,0.0,0.0,0,560)
DeclareParameter("chi.simMot.per.Freq", "Standard Frequency [Hz] []", 76, 50, \
0.0,0.0,0.0,0,560)
DeclareParameter("chi.simMot.per.Voltage", "Standard Voltage [V] []", 77, 400, \
0.0,0.0,0.0,0,560)
DeclareVariable("chi.simMot.P", "Number of poles [:#(type=Integer)]", 367, 0, \
0.0,0.0,0.0,0,517)
DeclareVariable("chi.simMot.J", "Moment of inertia", 368, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.Lr", "Rotor inductance [H] []", 369, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.Ls", "Stator inductance [H] []", 370, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.Lm", "Mutual inductance [H] []", 371, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.Rr", "Rotor resistance [ohm] []", 372, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.Rs", "Stator resistance [ohm] []", 373, 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("chi.simMot.have_controller", "Set to true for enable PID control, False for simple speed control [:#(type=Boolean)]",\
 78, true, 0.0,0.0,0.0,0,562)
DeclareParameter("chi.simMot.reverseActing", "Set to true for reverseActing in heating and set to false in cooling mode [:#(type=Boolean)]",\
 79, false, 0.0,0.0,0.0,0,562)
DeclareVariable("chi.simMot.controllerType", "Type of controller [:#(type=Modelica.Blocks.Types.SimpleController)]",\
 374, 1, 1.0,4.0,0.0,0,517)
DeclareVariable("chi.simMot.k", "Gain of controller", 375, 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.simMot.Ti", "Time constant of Integrator block [s]", 376, \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("chi.simMot.Td", "Time constant of Derivative block [s]", 377, \
0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.simMot.yMax", "Upper limit of output", 378, 1, 0.0,0.0,0.0,\
0,513)
DeclareVariable("chi.simMot.yMin", "Lower limit of output", 379, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.v_rms", "RMS voltage", 380, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.i_rms", "RMS current", 554, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.pow_gap", "", 555, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.theta_s", "Supply voltage phase angel [rad|deg]", 556,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.der(theta_s)", "der(Supply voltage phase angel) [rad/s]",\
 381, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.simMot.omega", "Supply voltage angular frequency [rad/s]", \
"chi.simMot.der(theta_s)", 1, 5, 381, 0)
DeclareAlias2("chi.simMot.v[1]", "Voltage vector [V]", "Sou.terminal.v[1]", 1, 5,\
 25, 0)
DeclareAlias2("chi.simMot.v[2]", "Voltage vector [V]", "Sou.terminal.v[2]", 1, 5,\
 26, 0)
DeclareAlias2("chi.simMot.i[1]", "Current vector [A]", "Sou.terminal.i[1]", -1, 5,\
 509, 0)
DeclareAlias2("chi.simMot.i[2]", "Current vector [A]", "Sou.terminal.i[2]", -1, 5,\
 510, 0)
DeclareAlias2("chi.simMot.Vrms.y", "Value of Real output", "chi.simMot.v_rms", 1,\
 5, 380, 0)
DeclareVariable("chi.simMot.fre.y", "Value of Real output", 382, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.VFDfre.u1", "Connector of Real input signal 1", 557,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("chi.simMot.VFDfre.u2", "Connector of Real input signal 2", \
"chi.simMot.fre.y", 1, 5, 382, 0)
DeclareAlias2("chi.simMot.VFDfre.y", "Connector of Real output signal", \
"chi.simMot.torSpe.frequencyConversion.f", 1, 5, 574, 0)
DeclareAlias2("chi.simMot.VFDvol.u1", "Connector of Real input signal 1", \
"chi.simMot.v_rms", 1, 5, 380, 0)
DeclareAlias2("chi.simMot.VFDvol.u2", "Connector of Real input signal 2", \
"chi.simMot.VFDfre.u1", 1, 5, 557, 0)
DeclareAlias2("chi.simMot.VFDvol.y", "Connector of Real output signal", \
"chi.simMot.torSpe.volCon.V_rms", 1, 5, 572, 0)
DeclareAlias2("chi.simMot.setPoi", "Set point of control target", "TSet.y", 1, 5,\
 502, 0)
DeclareAlias2("chi.simMot.mea", "Measured value of control target", "senTem.T", 1,\
 1, 0, 0)
DeclareAlias2("chi.simMot.tau_m", "Load torque [N.m]", "chi.mecChi.shaft.tau", 1,\
 5, 547, 0)
DeclareAlias2("chi.simMot.current_Block.i_ds", "", "chi.simMot.torSpe.motMod.int_ds.y", 1,\
 1, 6, 0)
DeclareAlias2("chi.simMot.current_Block.i_qs", "", "chi.simMot.torSpe.motMod.int_qs.y", 1,\
 1, 5, 0)
DeclareAlias2("chi.simMot.current_Block.wt", "", "chi.simMot.integrator.y", 1, 1,\
 2, 0)
DeclareVariable("chi.simMot.current_Block.I_a", "", 558, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.current_Block.I_b", "", 559, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.current_Block.I_c", "", 560, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.speBlo.tau_e", "", 561, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("chi.simMot.speBlo.tau_m", "", "chi.mecChi.shaft.tau", 1, 5, 547, 0)
DeclareVariable("chi.simMot.speBlo.omega", "", 562, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.speBlo.omega_r", "", 563, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.speBlo.N", "", 564, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.speBlo.J", "", 383, 0.0131, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.speBlo.P", "[:#(type=Integer)]", 384, 4, 0.0,0.0,0.0,\
0,517)
DeclareAlias2("chi.simMot.speBlo.feedback.u1", "Commanded input", \
"chi.simMot.speBlo.tau_e", 1, 5, 561, 0)
DeclareAlias2("chi.simMot.speBlo.feedback.u2", "Feedback input", \
"chi.mecChi.shaft.tau", 1, 5, 547, 0)
DeclareVariable("chi.simMot.speBlo.feedback.y", "", 565, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.speBlo.gain.k", "Gain value multiplied with input signal [1]",\
 385, 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.simMot.speBlo.gain.u", "Input signal connector", \
"chi.simMot.speBlo.feedback.y", 1, 5, 565, 0)
DeclareVariable("chi.simMot.speBlo.gain.y", "Output signal connector", 566, 0.0,\
 0.0,0.0,0.0,0,512)
DeclareParameter("chi.simMot.speBlo.integrator.k", "Integrator gain [1]", 80, 1,\
 0.0,0.0,0.0,0,560)
DeclareVariable("chi.simMot.speBlo.integrator.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 386, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.speBlo.integrator.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 387, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.speBlo.integrator.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 388, 3, 1.0,4.0,0.0,0,517)
DeclareVariable("chi.simMot.speBlo.integrator.y_start", "Initial or guess value of output (= state)",\
 389, 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.simMot.speBlo.integrator.u", "Connector of Real input signal",\
 "chi.simMot.speBlo.gain.y", 1, 5, 566, 0)
DeclareAlias2("chi.simMot.speBlo.integrator.y", "Connector of Real output signal",\
 "chi.mecChi.ine.w", 1, 1, 1, 0)
DeclareAlias2("chi.simMot.speBlo.integrator.der(y)", "der(Connector of Real output signal)",\
 "chi.mecChi.ine.der(w)", 1, 6, 1, 0)
DeclareVariable("chi.simMot.speBlo.integrator.local_reset", "[:#(type=Boolean)]",\
 390, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.speBlo.integrator.local_set", "", 391, 0, 0.0,0.0,\
0.0,0,1537)
DeclareVariable("chi.simMot.speBlo.gain1.k", "Gain value multiplied with input signal [1]",\
 392, 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.simMot.speBlo.gain1.u", "Input signal connector", \
"chi.mecChi.ine.w", 1, 1, 1, 0)
DeclareAlias2("chi.simMot.speBlo.gain1.y", "Output signal connector", \
"chi.simMot.speBlo.N", 1, 5, 564, 0)
DeclareAlias2("chi.simMot.speBlo.feedback1.u1", "Commanded input", \
"chi.simMot.speBlo.omega", 1, 5, 562, 0)
DeclareAlias2("chi.simMot.speBlo.feedback1.u2", "Feedback input", \
"chi.mecChi.ine.w", 1, 1, 1, 0)
DeclareAlias2("chi.simMot.speBlo.feedback1.y", "", "chi.simMot.speBlo.omega_r", 1,\
 5, 563, 0)
DeclareAlias2("chi.simMot.speBlo.omega_r1", "", "chi.mecChi.ine.w", 1, 1, 1, 0)
DeclareParameter("chi.simMot.integrator.k", "Integrator gain [1]", 81, 1, \
0.0,0.0,0.0,0,560)
DeclareVariable("chi.simMot.integrator.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 393, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.integrator.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 394, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.integrator.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 395, 3, 1.0,4.0,0.0,0,517)
DeclareParameter("chi.simMot.integrator.y_start", "Initial or guess value of output (= state)",\
 82, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("chi.simMot.integrator.u", "Connector of Real input signal", 567,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("chi.simMot.integrator.y", "Connector of Real output signal", 2, \
0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("chi.simMot.integrator.der(y)", "der(Connector of Real output signal)",\
 2, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.integrator.local_reset", "[:#(type=Boolean)]", 396, \
false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.integrator.local_set", "", 397, 0, 0.0,0.0,0.0,0,1537)
DeclareAlias2("chi.simMot.i_ds.y", "Value of Real output", "chi.simMot.torSpe.motMod.int_ds.y", 1,\
 1, 6, 0)
DeclareAlias2("chi.simMot.i_qs.y", "Value of Real output", "chi.simMot.torSpe.motMod.int_qs.y", 1,\
 1, 5, 0)
DeclareAlias2("chi.simMot.angFre.y", "Value of Real output", "chi.simMot.speBlo.omega", 1,\
 5, 562, 0)
DeclareVariable("chi.simMot.torSpe.P", "Number of poles [:#(type=Integer)]", 398,\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("chi.simMot.torSpe.J", "", 399, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.torSpe.Lr", "", 400, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.torSpe.Ls", "", 401, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.torSpe.Rr", "", 402, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.torSpe.Lm", "", 403, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.torSpe.Rs", "", 404, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.simMot.torSpe.V_rms", "Prescribed RMS voltage [V]", \
"chi.simMot.torSpe.volCon.V_rms", 1, 5, 572, 0)
DeclareAlias2("chi.simMot.torSpe.f", "Controllable freuqency to the motor [Hz]",\
 "chi.simMot.torSpe.frequencyConversion.f", 1, 5, 574, 0)
DeclareAlias2("chi.simMot.torSpe.omega_r", "Prescribed rotational speed of rotor [rad/s]",\
 "chi.simMot.speBlo.omega_r", 1, 5, 563, 0)
DeclareAlias2("chi.simMot.torSpe.tau_e", "Electromagenetic torque of rotor [N.m]",\
 "chi.simMot.speBlo.tau_e", 1, 5, 561, 0)
DeclareVariable("chi.simMot.torSpe.motMod.Lr", "[Ohm]", 405, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.Ls", "[Ohm]", 406, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.Rr", "[Ohm]", 407, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.Lm", "[Ohm]", 408, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.Rs", "[Ohm]", 409, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.simMot.torSpe.motMod.v_ds", "", "chi.simMot.torSpe.volCon.v_ds", 1,\
 5, 573, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.v_qs", "", "chi.simMot.torSpe.volCon.v_qs", 1,\
 5, 449, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.omega", "", "chi.simMot.torSpe.frequencyConversion.omega", 1,\
 5, 575, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.omega_r", "", "chi.simMot.speBlo.omega_r", 1,\
 5, 563, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_qs", "", "chi.simMot.torSpe.motMod.int_qs.y", 1,\
 1, 5, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_ds", "", "chi.simMot.torSpe.motMod.int_ds.y", 1,\
 1, 6, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_qr", "", "chi.simMot.torSpe.motMod.int_qr.y", 1,\
 1, 3, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_dr", "", "chi.simMot.torSpe.motMod.int_dr.y", 1,\
 1, 4, 0)
DeclareVariable("chi.simMot.torSpe.motMod.i_qr_block.Lr", "", 410, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.i_qr_block.Rr", "", 411, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.i_qr_block.Lm", "", 412, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareAlias2("chi.simMot.torSpe.motMod.i_qr_block.v_qr", "", "chi.simMot.torSpe.motMod.v_qr.k", 1,\
 7, 92, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_qr_block.i_qr", "", "chi.simMot.torSpe.motMod.int_qr.y", 1,\
 1, 3, 0)
DeclareVariable("chi.simMot.torSpe.motMod.i_qr_block.der_i_qs", "", 568, 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("chi.simMot.torSpe.motMod.i_qr_block.omega_r", "", \
"chi.simMot.speBlo.omega_r", 1, 5, 563, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_qr_block.i_dr", "", "chi.simMot.torSpe.motMod.int_dr.y", 1,\
 1, 4, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_qr_block.i_ds", "", "chi.simMot.torSpe.motMod.int_ds.y", 1,\
 1, 6, 0)
DeclareVariable("chi.simMot.torSpe.motMod.i_qr_block.der_i_qr", "", 569, 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("chi.simMot.torSpe.motMod.int_qr.k", "Integrator gain [1]", 83,\
 1, 0.0,0.0,0.0,0,560)
DeclareVariable("chi.simMot.torSpe.motMod.int_qr.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 413, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.torSpe.motMod.int_qr.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 414, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.torSpe.motMod.int_qr.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 415, 3, 1.0,4.0,0.0,0,517)
DeclareParameter("chi.simMot.torSpe.motMod.int_qr.y_start", "Initial or guess value of output (= state)",\
 84, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("chi.simMot.torSpe.motMod.int_qr.u", "Connector of Real input signal",\
 "chi.simMot.torSpe.motMod.i_qr_block.der_i_qr", 1, 5, 569, 0)
DeclareState("chi.simMot.torSpe.motMod.int_qr.y", "Connector of Real output signal",\
 3, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("chi.simMot.torSpe.motMod.int_qr.der(y)", "der(Connector of Real output signal)",\
 3, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.torSpe.motMod.int_qr.local_reset", "[:#(type=Boolean)]",\
 416, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.torSpe.motMod.int_qr.local_set", "", 417, 0, \
0.0,0.0,0.0,0,1537)
DeclareVariable("chi.simMot.torSpe.motMod.i_dr_block.Lr", "", 418, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.i_dr_block.Rr", "", 419, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.i_dr_block.Lm", "", 420, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareAlias2("chi.simMot.torSpe.motMod.i_dr_block.v_dr", "", "chi.simMot.torSpe.motMod.v_dr.k", 1,\
 7, 87, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_dr_block.i_qr", "", "chi.simMot.torSpe.motMod.int_qr.y", 1,\
 1, 3, 0)
DeclareVariable("chi.simMot.torSpe.motMod.i_dr_block.der_i_ds", "", 570, 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("chi.simMot.torSpe.motMod.i_dr_block.omega_r", "", \
"chi.simMot.speBlo.omega_r", 1, 5, 563, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_dr_block.i_dr", "", "chi.simMot.torSpe.motMod.int_dr.y", 1,\
 1, 4, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_dr_block.i_qs", "", "chi.simMot.torSpe.motMod.int_qs.y", 1,\
 1, 5, 0)
DeclareVariable("chi.simMot.torSpe.motMod.i_dr_block.der_i_dr", "", 571, 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("chi.simMot.torSpe.motMod.int_dr.k", "Integrator gain [1]", 85,\
 1, 0.0,0.0,0.0,0,560)
DeclareVariable("chi.simMot.torSpe.motMod.int_dr.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 421, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.torSpe.motMod.int_dr.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 422, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.torSpe.motMod.int_dr.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 423, 3, 1.0,4.0,0.0,0,517)
DeclareParameter("chi.simMot.torSpe.motMod.int_dr.y_start", "Initial or guess value of output (= state)",\
 86, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("chi.simMot.torSpe.motMod.int_dr.u", "Connector of Real input signal",\
 "chi.simMot.torSpe.motMod.i_dr_block.der_i_dr", 1, 5, 571, 0)
DeclareState("chi.simMot.torSpe.motMod.int_dr.y", "Connector of Real output signal",\
 4, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("chi.simMot.torSpe.motMod.int_dr.der(y)", "der(Connector of Real output signal)",\
 4, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.torSpe.motMod.int_dr.local_reset", "[:#(type=Boolean)]",\
 424, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.torSpe.motMod.int_dr.local_set", "", 425, 0, \
0.0,0.0,0.0,0,1537)
DeclareParameter("chi.simMot.torSpe.motMod.v_dr.k", "Constant output value", 87,\
 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("chi.simMot.torSpe.motMod.v_dr.y", "Connector of Real output signal",\
 "chi.simMot.torSpe.motMod.v_dr.k", 1, 7, 87, 0)
DeclareVariable("chi.simMot.torSpe.motMod.i_qs_block.Lr", "", 426, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.i_qs_block.Rr", "", 427, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.i_qs_block.Lm", "", 428, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.i_qs_block.Rs", "", 429, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.i_qs_block.Ls", "", 430, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareAlias2("chi.simMot.torSpe.motMod.i_qs_block.v_qs", "", "chi.simMot.torSpe.volCon.v_qs", 1,\
 5, 449, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_qs_block.i_qs", "", "chi.simMot.torSpe.motMod.int_qs.y", 1,\
 1, 5, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_qs_block.der_i_qr", "", \
"chi.simMot.torSpe.motMod.i_qr_block.der_i_qr", 1, 5, 569, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_qs_block.omega", "", "chi.simMot.torSpe.frequencyConversion.omega", 1,\
 5, 575, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_qs_block.i_dr", "", "chi.simMot.torSpe.motMod.int_dr.y", 1,\
 1, 4, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_qs_block.i_ds", "", "chi.simMot.torSpe.motMod.int_ds.y", 1,\
 1, 6, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_qs_block.der_i_qs", "", \
"chi.simMot.torSpe.motMod.i_qr_block.der_i_qs", 1, 5, 568, 0)
DeclareParameter("chi.simMot.torSpe.motMod.int_qs.k", "Integrator gain [1]", 88,\
 1, 0.0,0.0,0.0,0,560)
DeclareVariable("chi.simMot.torSpe.motMod.int_qs.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 431, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.torSpe.motMod.int_qs.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 432, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.torSpe.motMod.int_qs.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 433, 3, 1.0,4.0,0.0,0,517)
DeclareParameter("chi.simMot.torSpe.motMod.int_qs.y_start", "Initial or guess value of output (= state)",\
 89, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("chi.simMot.torSpe.motMod.int_qs.u", "Connector of Real input signal",\
 "chi.simMot.torSpe.motMod.i_qr_block.der_i_qs", 1, 5, 568, 0)
DeclareState("chi.simMot.torSpe.motMod.int_qs.y", "Connector of Real output signal",\
 5, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("chi.simMot.torSpe.motMod.int_qs.der(y)", "der(Connector of Real output signal)",\
 5, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.torSpe.motMod.int_qs.local_reset", "[:#(type=Boolean)]",\
 434, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.torSpe.motMod.int_qs.local_set", "", 435, 0, \
0.0,0.0,0.0,0,1537)
DeclareVariable("chi.simMot.torSpe.motMod.i_ds_block.Lr", "", 436, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.i_ds_block.Rr", "", 437, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.i_ds_block.Lm", "", 438, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.i_ds_block.Rs", "", 439, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.torSpe.motMod.i_ds_block.Ls", "", 440, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareAlias2("chi.simMot.torSpe.motMod.i_ds_block.v_ds", "", "chi.simMot.torSpe.volCon.v_ds", 1,\
 5, 573, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_ds_block.i_ds", "", "chi.simMot.torSpe.motMod.int_ds.y", 1,\
 1, 6, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_ds_block.der_i_dr", "", \
"chi.simMot.torSpe.motMod.i_dr_block.der_i_dr", 1, 5, 571, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_ds_block.omega", "", "chi.simMot.torSpe.frequencyConversion.omega", 1,\
 5, 575, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_ds_block.i_qr", "", "chi.simMot.torSpe.motMod.int_qr.y", 1,\
 1, 3, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_ds_block.i_qs", "", "chi.simMot.torSpe.motMod.int_qs.y", 1,\
 1, 5, 0)
DeclareAlias2("chi.simMot.torSpe.motMod.i_ds_block.der_i_ds", "", \
"chi.simMot.torSpe.motMod.i_dr_block.der_i_ds", 1, 5, 570, 0)
DeclareParameter("chi.simMot.torSpe.motMod.int_ds.k", "Integrator gain [1]", 90,\
 1, 0.0,0.0,0.0,0,560)
DeclareVariable("chi.simMot.torSpe.motMod.int_ds.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 441, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.torSpe.motMod.int_ds.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 442, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.torSpe.motMod.int_ds.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 443, 3, 1.0,4.0,0.0,0,517)
DeclareParameter("chi.simMot.torSpe.motMod.int_ds.y_start", "Initial or guess value of output (= state)",\
 91, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("chi.simMot.torSpe.motMod.int_ds.u", "Connector of Real input signal",\
 "chi.simMot.torSpe.motMod.i_dr_block.der_i_ds", 1, 5, 570, 0)
DeclareState("chi.simMot.torSpe.motMod.int_ds.y", "Connector of Real output signal",\
 6, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("chi.simMot.torSpe.motMod.int_ds.der(y)", "der(Connector of Real output signal)",\
 6, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.torSpe.motMod.int_ds.local_reset", "[:#(type=Boolean)]",\
 444, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.torSpe.motMod.int_ds.local_set", "", 445, 0, \
0.0,0.0,0.0,0,1537)
DeclareParameter("chi.simMot.torSpe.motMod.v_qr.k", "Constant output value", 92,\
 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("chi.simMot.torSpe.motMod.v_qr.y", "Connector of Real output signal",\
 "chi.simMot.torSpe.motMod.v_qr.k", 1, 7, 92, 0)
DeclareVariable("chi.simMot.torSpe.torBlo.P", "Number of pole pairs [:#(type=Integer)]",\
 446, 0, 0.0,0.0,0.0,0,517)
DeclareVariable("chi.simMot.torSpe.torBlo.Lm", "", 447, 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.torSpe.torBlo.J", "", 448, 0.0131, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.simMot.torSpe.torBlo.i_qs", "", "chi.simMot.torSpe.motMod.int_qs.y", 1,\
 1, 5, 0)
DeclareAlias2("chi.simMot.torSpe.torBlo.i_ds", "", "chi.simMot.torSpe.motMod.int_ds.y", 1,\
 1, 6, 0)
DeclareAlias2("chi.simMot.torSpe.torBlo.i_qr", "", "chi.simMot.torSpe.motMod.int_qr.y", 1,\
 1, 3, 0)
DeclareAlias2("chi.simMot.torSpe.torBlo.i_dr", "", "chi.simMot.torSpe.motMod.int_dr.y", 1,\
 1, 4, 0)
DeclareAlias2("chi.simMot.torSpe.torBlo.tau_e", "", "chi.simMot.speBlo.tau_e", 1,\
 5, 561, 0)
DeclareVariable("chi.simMot.torSpe.volCon.V_rms", "", 572, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.torSpe.volCon.v_qs", "", 449, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.torSpe.volCon.v_ds", "", 573, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.torSpe.frequencyConversion.f", "Value in hertz", 574,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.torSpe.frequencyConversion.omega", "Value in radian per second",\
 575, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("chi.simMot.shaft.phi", "Absolute rotation angle of flange [rad|deg]",\
 "chi.mecChi.ine.phi", 1, 5, 548, 4)
DeclareAlias2("chi.simMot.shaft.tau", "Cut torque in the flange [N.m]", \
"chi.mecChi.shaft.tau", -1, 5, 547, 132)
DeclareVariable("chi.simMot.speed.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 450, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("chi.simMot.speed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "chi.mecChi.ine.phi", 1, 5, 548, 4)
DeclareAlias2("chi.simMot.speed.flange.tau", "Cut torque in the flange [N.m]", \
"chi.mecChi.shaft.tau", -1, 5, 547, 132)
DeclareVariable("chi.simMot.speed.phi_support", "Absolute angle of support flange [rad|deg]",\
 451, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.simMot.speed.exact", "Is true/false for exact treatment/filtering of the input signal, respectively [:#(type=Boolean)]",\
 452, true, 0.0,0.0,0.0,0,515)
DeclareParameter("chi.simMot.speed.f_crit", "If exact=false, critical frequency of filter to filter input signal [Hz]",\
 93, 50, 0.0,0.0,0.0,0,560)
DeclareState("chi.simMot.speed.phi", "Rotation angle of flange with respect to support [rad|deg]",\
 7, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("chi.simMot.speed.der(phi)", "der(Rotation angle of flange with respect to support) [rad/s]",\
 7, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("chi.simMot.speed.w", "Angular velocity of flange with respect to support [rad/s]",\
 "chi.mecChi.ine.w", 1, 1, 1, 0)
DeclareVariable("chi.simMot.speed.a", "If exact=false, angular acceleration of flange with respect to support else dummy [rad/s2]",\
 453, 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.simMot.speed.w_ref", "Reference angular velocity of flange with respect to support as input signal [rad/s]",\
 "chi.mecChi.ine.w", 1, 1, 1, 0)
DeclareVariable("chi.simMot.speed.w_crit", "Critical frequency [rad/s]", 454, \
0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("chi.simMot.angFre1.y", "Value of Real output", "chi.simMot.integrator.u", 1,\
 5, 567, 0)
DeclareVariable("chi.simMot.VFD_Equivalent_Freq.k", "Gain value multiplied with input signal [1]",\
 455, 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.simMot.VFD_Equivalent_Freq.u", "Input signal connector", \
"TSet.y", 1, 5, 502, 0)
DeclareVariable("chi.simMot.VFD_Equivalent_Freq.y", "Output signal connector", 503,\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("chi.simMot.VFD.u_s", "Connector of setpoint input signal", \
"TSet.y", 1, 5, 502, 0)
DeclareAlias2("chi.simMot.VFD.u_m", "Connector of measurement input signal", \
"senTem.T", 1, 1, 0, 0)
DeclareVariable("chi.simMot.VFD.y", "Connector of actuator output signal", 576, \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.VFD.controlError", "Control error (set point - measurement)",\
 577, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.VFD.controllerType", "Type of controller [:#(type=Modelica.Blocks.Types.SimpleController)]",\
 456, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("chi.simMot.VFD.k", "Gain of controller", 457, 0.0, 0.0,1E+100,\
0.0,0,513)
DeclareVariable("chi.simMot.VFD.Ti", "Time constant of Integrator block [s]", 458,\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("chi.simMot.VFD.Td", "Time constant of Derivative block [s]", 459,\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("chi.simMot.VFD.yMax", "Upper limit of output", 460, 1, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.VFD.yMin", "Lower limit of output", 461, 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("chi.simMot.VFD.wp", "Set-point weight for Proportional block (0..1)",\
 94, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("chi.simMot.VFD.wd", "Set-point weight for Derivative block (0..1)",\
 95, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("chi.simMot.VFD.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 96, 0.9, 1E-13,1E+100,0.0,0,560)
DeclareParameter("chi.simMot.VFD.Nd", "The higher Nd, the more ideal the derivative block",\
 97, 10, 1E-13,1E+100,0.0,0,560)
DeclareVariable("chi.simMot.VFD.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 462, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("chi.simMot.VFD.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 463, 0, 0.0,0.0,0.0,0,513)
DeclareParameter("chi.simMot.VFD.xd_start", "Initial or guess value for state of derivative block",\
 98, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("chi.simMot.VFD.y_start", "Initial value of output", 99, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("chi.simMot.VFD.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 464, true, 0.0,0.0,0.0,0,515)
DeclareVariable("chi.simMot.VFD.reverseActing", "Set to true for reverse acting, or false for direct acting control action [:#(type=Boolean)]",\
 465, false, 0.0,0.0,0.0,0,515)
DeclareVariable("chi.simMot.VFD.reset", "Type of controller output reset [:#(type=Buildings.Types.Reset)]",\
 466, 1, 1.0,3.0,0.0,0,517)
DeclareVariable("chi.simMot.VFD.y_reset", "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == Buildings.Types.Reset.Parameter",\
 467, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.simMot.VFD.addP.u1", "Connector of Real input signal 1", \
"TSet.y", 1, 5, 502, 0)
DeclareAlias2("chi.simMot.VFD.addP.u2", "Connector of Real input signal 2", \
"senTem.T", 1, 1, 0, 0)
DeclareVariable("chi.simMot.VFD.addP.y", "Connector of Real output signal", 578,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.VFD.addP.k1", "Gain of input signal 1", 468, 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.VFD.addP.k2", "Gain of input signal 2", 469, 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("chi.simMot.VFD.P.k", "Gain value multiplied with input signal [1]",\
 100, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("chi.simMot.VFD.P.u", "Input signal connector", "chi.simMot.VFD.addP.y", 1,\
 5, 578, 0)
DeclareVariable("chi.simMot.VFD.P.y", "Output signal connector", 579, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.VFD.addPID.k1", "Gain of input signal 1", 470, 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.VFD.addPID.k2", "Gain of input signal 2", 471, 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.VFD.addPID.k3", "Gain of input signal 3", 472, 1, \
0.0,0.0,0.0,0,513)
DeclareAlias2("chi.simMot.VFD.addPID.u1", "Connector of Real input signal 1", \
"chi.simMot.VFD.P.y", 1, 5, 579, 0)
DeclareVariable("chi.simMot.VFD.addPID.u2", "Connector of Real input signal 2", 473,\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("chi.simMot.VFD.addPID.u3", "Connector of Real input signal 3", \
"chi.simMot.VFD.I.y", 1, 1, 8, 0)
DeclareVariable("chi.simMot.VFD.addPID.y", "Connector of Real output signal", 580,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.VFD.unitTime", "[s]", 474, 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("chi.simMot.VFD.revAct", "Switch for sign for reverse or direct acting controller",\
 475, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.simMot.VFD.with_I", "Boolean flag to enable integral action [:#(type=Boolean)]",\
 476, true, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.VFD.with_D", "Boolean flag to enable derivative action [:#(type=Boolean)]",\
 477, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chi.simMot.VFD.Dzero.k", "Constant output value", 478, 0, \
0.0,0.0,0.0,0,1537)
DeclareVariable("chi.simMot.VFD.Dzero.y", "Connector of Real output signal", 479,\
 0.0, 0.0,0.0,0.0,0,1537)
DeclareVariable("chi.simMot.VFD.y_reset_internal", "Internal connector for controller output reset",\
 480, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.simMot.VFD.addI.k1", "Gain of input signal 1", 481, 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("chi.simMot.VFD.addI.k2", "Gain of input signal 2", 482, 0.0, \
0.0,0.0,0.0,0,2561)
DeclareParameter("chi.simMot.VFD.addI.k3", "Gain of input signal 3", 101, 1, \
0.0,0.0,0.0,0,2608)
DeclareAlias2("chi.simMot.VFD.addI.u1", "Connector of Real input signal 1", \
"TSet.y", 1, 5, 502, 1024)
DeclareAlias2("chi.simMot.VFD.addI.u2", "Connector of Real input signal 2", \
"senTem.T", 1, 1, 0, 1024)
DeclareVariable("chi.simMot.VFD.addI.u3", "Connector of Real input signal 3", 581,\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("chi.simMot.VFD.addI.y", "Connector of Real output signal", 582,\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("chi.simMot.VFD.addSat.u1", "Connector of Real input signal 1", \
"chi.simMot.VFD.y", 1, 5, 576, 1024)
DeclareAlias2("chi.simMot.VFD.addSat.u2", "Connector of Real input signal 2", \
"chi.simMot.VFD.gainPID.y", 1, 5, 584, 1024)
DeclareVariable("chi.simMot.VFD.addSat.y", "Connector of Real output signal", 583,\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("chi.simMot.VFD.addSat.k1", "Gain of input signal 1", 483, 1, \
0.0,0.0,0.0,0,2561)
DeclareVariable("chi.simMot.VFD.addSat.k2", "Gain of input signal 2", 484, -1, \
0.0,0.0,0.0,0,2561)
DeclareVariable("chi.simMot.VFD.gainPID.k", "Gain value multiplied with input signal [1]",\
 485, 1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("chi.simMot.VFD.gainPID.u", "Input signal connector", \
"chi.simMot.VFD.addPID.y", 1, 5, 580, 1024)
DeclareVariable("chi.simMot.VFD.gainPID.y", "Output signal connector", 584, 0.0,\
 0.0,0.0,0.0,0,2624)
DeclareVariable("chi.simMot.VFD.gainTrack.k", "Gain value multiplied with input signal [1]",\
 486, 1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("chi.simMot.VFD.gainTrack.u", "Input signal connector", \
"chi.simMot.VFD.addSat.y", 1, 5, 583, 1024)
DeclareAlias2("chi.simMot.VFD.gainTrack.y", "Output signal connector", \
"chi.simMot.VFD.addI.u3", 1, 5, 581, 1024)
DeclareVariable("chi.simMot.VFD.limiter.uMax", "Upper limits of input signals", 487,\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.simMot.VFD.limiter.uMin", "Lower limits of input signals", 488,\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.simMot.VFD.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 489, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.simMot.VFD.limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 490, true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("chi.simMot.VFD.limiter.u", "Connector of Real input signal", \
"chi.simMot.VFD.gainPID.y", 1, 5, 584, 1024)
DeclareAlias2("chi.simMot.VFD.limiter.y", "Connector of Real output signal", \
"chi.simMot.VFD.y", 1, 5, 576, 1024)
DeclareAlias2("chi.simMot.VFD.I.u", "Connector of Real input signal", \
"chi.simMot.VFD.addI.y", 1, 5, 582, 0)
DeclareState("chi.simMot.VFD.I.y", "Connector of Real output signal", 8, 0.0, \
0.0,0.0,0.0,0,544)
DeclareDerivative("chi.simMot.VFD.I.der(y)", "der(Connector of Real output signal)",\
 8, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("chi.simMot.VFD.I.k", "Integrator gain [1]", 491, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("chi.simMot.VFD.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 492, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("chi.simMot.VFD.I.y_start", "Initial or guess value of output (= state)",\
 493, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.VFD.I.reset", "Type of integrator reset [:#(type=Buildings.Types.Reset)]",\
 494, 1, 1.0,3.0,0.0,0,517)
DeclareVariable("chi.simMot.VFD.I.y_reset", "Value to which integrator is reset, used if reset = Buildings.Types.Reset.Parameter",\
 495, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("chi.simMot.VFD.I.y_reset_internal", "Internal connector for integrator reset",\
 496, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.simMot.VFD.I.trigger_internal", "Needed to use conditional connector trigger [:#(type=Boolean)]",\
 497, false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("chi.simMot.switch1.u1", "Connector of first Real input signal", \
"chi.simMot.VFD.y", 1, 5, 576, 0)
DeclareAlias2("chi.simMot.switch1.u2", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "chi.simMot.have_controller", 1, 7, 78, 65)
DeclareVariable("chi.simMot.switch1.u3", "Connector of second Real input signal",\
 504, 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("chi.simMot.switch1.y", "Connector of Real output signal", \
"chi.simMot.VFDfre.u1", 1, 5, 557, 0)
DeclareAlias2("chi.simMot.booleanExpression.y", "Value of Boolean output [:#(type=Boolean)]",\
 "chi.simMot.have_controller", 1, 7, 78, 65)
DeclareAlias2("chi.simMot.realExpression.y", "Value of Real output", \
"chi.simMot.switch1.u3", 1, 5, 504, 0)
DeclareAlias2("chi.setPoi", "Set point of control target", "TSet.y", 1, 5, 502, 0)
DeclareAlias2("chi.meaPoi", "Measured value of control target", "senTem.T", 1, 1,\
 0, 0)
DeclareVariable("chi.COP_is_for_cooling", "Set to true if the specified COP is for cooling [:#(type=Boolean)]",\
 498, true, 0.0,0.0,0.0,0,2563)
DeclareVariable("chi.TUseAct_nominal", "Nominal evaporator temperature for chiller or condenser temperature for heat pump,     taking into account pinch temperature between fluid and refrigerant [K|degC]",\
 499, 276.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("chi.cp1_default", "Specific heat capacity of medium 1 at default medium state [J/(kg.K)]",\
 500, 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("chi.cp2_default", "Specific heat capacity of medium 2 at default medium state [J/(kg.K)]",\
 501, 4184, 0.0,0.0,0.0,0,2561)
DeclareParameter("TEva_in.height", "Height of ramps", 102, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("TEva_in.duration", "Duration of ramp (= 0.0 gives a Step) [s]",\
 103, 600, 0.0,1E+100,0.0,0,560)
DeclareAlias2("TEva_in.y", "Connector of Real output signal", "sou2.T_in_internal", 1,\
 5, 508, 0)
DeclareParameter("TEva_in.offset", "Offset of output signal y", 104, 290.15, \
0.0,0.0,0.0,0,560)
DeclareParameter("TEva_in.startTime", "Output y = offset for time < startTime [s]",\
 105, 0, 0.0,0.0,0.0,0,560)
DeclareOutput("CPUtime", "[s]", 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("EventCounter", "", 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("NonlinearSystems.initialization[1].Calls", "Number of calls to solve this system",\
 585, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("NonlinearSystems.initialization[1].Residues", "Number of evaluations of the system residual",\
 586, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("NonlinearSystems.initialization[1].Iterations", \
"Number of iterations performed to solve this system", 587, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("NonlinearSystems.initialization[1].Jacobians", "Number of evaluations of the analytic system Jacobian",\
 588, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("NonlinearSystems.simulation[1].Calls", "Number of calls to solve this system",\
 589, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("NonlinearSystems.simulation[1].Residues", "Number of evaluations of the system residual",\
 590, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("NonlinearSystems.simulation[1].Iterations", "Number of iterations performed to solve this system",\
 591, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("NonlinearSystems.simulation[1].Jacobians", "Number of evaluations of the analytic system Jacobian",\
 592, 0.0, 0.0,0.0,0.0,0,512)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
if (initialCall) DYNX(did_->xInitial_var, 0)=DYNX(W_,584);
else if (DYNHReject) DYNX(W_,584)=did_->xInitial_var2[0]; else did_->xInitial_var2[0]=
  DYNX(W_,584);
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(W_,546), -47612.06896551724, 4);
DoRemember_(DYNX(W_,526), 0.0, 0);
DoRemember_(DYNX(W_,570), 0.0, 2);
DoRemember_(DYNX(W_,568), 0.0, 3);
DoRemember_(DYNX(F_,1), 0.0, 1);
EndEqBlock
EndDataBlock

BreakSectionFunctionStart(2);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionCallNew(3);
BreakSectionFunctionEnd()
